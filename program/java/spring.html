<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.33">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/img/logo.png"><link rel="manifest" href="/manifest.json"><script async>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?36884888f7a05e80a42de77a45873e51";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s)})();</script><title>spring | stormbuf's blog</title><meta name="description" content="stormbuf 的博客">
    <link rel="modulepreload" href="/assets/app.edc637f8.js"><link rel="modulepreload" href="/assets/spring.html.04d48483.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/spring.html.ce16ee72.js">
    <link rel="stylesheet" href="/assets/style.924ef254.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">stormbuf&#39;s blog</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="home"><!--[--><!--]--> home <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="program"><span class="title">program</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="program"><span class="title">program</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/program/java/" class="router-link-active" aria-label="java"><!--[--><!--]--> java <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/program/golang/" class="" aria-label="golang"><!--[--><!--]--> golang <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/program/distributed/" class="" aria-label="分布式"><!--[--><!--]--> 分布式 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/program/frontEnd/" class="" aria-label="front-end"><!--[--><!--]--> front-end <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/db/" class="" aria-label="database"><!--[--><!--]--> database <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a href="/weekly/" class="" aria-label="weekly"><!--[--><!--]--> weekly <!--[--><!--]--></a></div><div class="navbar-item"><a href="/archivesPage/" class="" aria-label="timeline"><!--[--><!--]--> timeline <!--[--><!--]--></a></div><div class="navbar-item"><a href="/friends/" class="" aria-label="friends"><!--[--><!--]--> friends <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://stormbuf.top/rss.xml" target="_self" aria-label="RSS"><!--[--><!--]--> RSS <!----><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="home"><!--[--><!--]--> home <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="program"><span class="title">program</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="program"><span class="title">program</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/program/java/" class="router-link-active" aria-label="java"><!--[--><!--]--> java <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/program/golang/" class="" aria-label="golang"><!--[--><!--]--> golang <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/program/distributed/" class="" aria-label="分布式"><!--[--><!--]--> 分布式 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/program/frontEnd/" class="" aria-label="front-end"><!--[--><!--]--> front-end <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/db/" class="" aria-label="database"><!--[--><!--]--> database <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a href="/weekly/" class="" aria-label="weekly"><!--[--><!--]--> weekly <!--[--><!--]--></a></div><div class="navbar-item"><a href="/archivesPage/" class="" aria-label="timeline"><!--[--><!--]--> timeline <!--[--><!--]--></a></div><div class="navbar-item"><a href="/friends/" class="" aria-label="friends"><!--[--><!--]--> friends <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://stormbuf.top/rss.xml" target="_self" aria-label="RSS"><!--[--><!--]--> RSS <!----><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p class="sidebar-item sidebar-heading">spring <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/program/java/spring.html#beanfactorypostprocessor-接口" class="router-link-active router-link-exact-active sidebar-item" aria-label="BeanFactoryPostProcessor 接口"><!--[--><!--]--> BeanFactoryPostProcessor 接口 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/program/java/spring.html#beanfactory解析" class="router-link-active router-link-exact-active sidebar-item" aria-label="BeanFactory解析"><!--[--><!--]--> BeanFactory解析 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/program/java/spring.html#applicationcontext-解析" class="router-link-active router-link-exact-active sidebar-item" aria-label="ApplicationContext 解析"><!--[--><!--]--> ApplicationContext 解析 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/program/java/spring.html#applicationcontext-体系结构" class="router-link-active router-link-exact-active sidebar-item" aria-label="ApplicationContext 体系结构"><!--[--><!--]--> ApplicationContext 体系结构 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/program/java/spring.html#【核心】refresh-方法" class="router-link-active router-link-exact-active sidebar-item" aria-label="【核心】refresh 方法"><!--[--><!--]--> 【核心】refresh 方法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/program/java/spring.html#beandefinition-解析" class="router-link-active router-link-exact-active sidebar-item" aria-label="BeanDefinition 解析"><!--[--><!--]--> BeanDefinition 解析 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/program/java/spring.html#面向注解的解析" class="router-link-active router-link-exact-active sidebar-item" aria-label="面向注解的解析"><!--[--><!--]--> 面向注解的解析 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/program/java/spring.html#spring-扩展点解析" class="router-link-active router-link-exact-active sidebar-item" aria-label="Spring 扩展点解析"><!--[--><!--]--> Spring 扩展点解析 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/program/java/spring.html#广播机制" class="router-link-active router-link-exact-active sidebar-item" aria-label="广播机制"><!--[--><!--]--> 广播机制 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/program/java/spring.html#dogetbean-方法" class="router-link-active router-link-exact-active sidebar-item" aria-label="doGetBean 方法"><!--[--><!--]--> doGetBean 方法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/program/java/spring.html#createbean" class="router-link-active router-link-exact-active sidebar-item" aria-label="createBean"><!--[--><!--]--> createBean <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/program/java/spring.html#docreatebean" class="router-link-active router-link-exact-active sidebar-item" aria-label="doCreateBean"><!--[--><!--]--> doCreateBean <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/program/java/spring.html#createbeaninstance" class="router-link-active router-link-exact-active sidebar-item" aria-label="createBeanInstance"><!--[--><!--]--> createBeanInstance <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/program/java/spring.html#populatebean" class="router-link-active router-link-exact-active sidebar-item" aria-label="populateBean"><!--[--><!--]--> populateBean <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/program/java/spring.html#三级缓存" class="router-link-active router-link-exact-active sidebar-item" aria-label="三级缓存"><!--[--><!--]--> 三级缓存 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="spring" tabindex="-1"><a class="header-anchor" href="#spring" aria-hidden="true">#</a> spring</h1><h1 id="beanfactory" tabindex="-1"><a class="header-anchor" href="#beanfactory" aria-hidden="true">#</a> BeanFactory</h1><h2 id="beanfactorypostprocessor-接口" tabindex="-1"><a class="header-anchor" href="#beanfactorypostprocessor-接口" aria-hidden="true">#</a> BeanFactoryPostProcessor 接口</h2><p><code>BeanFactoryPostProcessor</code>是一个函数式接口，里面只有一个方法：</p><div class="language-java ext-java line-numbers-mode"><pre class="shiki" style="background-color:#0d1117;"><code><span class="line"><span style="color:#C9D1D9;">@</span><span style="color:#FF7B72;">FunctionalInterface</span></span>
<span class="line"><span style="color:#FF7B72;">public</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">interface</span><span style="color:#C9D1D9;"> </span><span style="color:#FFA657;">BeanFactoryPostProcessor</span><span style="color:#C9D1D9;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#8B949E;">  /**</span></span>
<span class="line"><span style="color:#8B949E;">   * Modify the application context&#39;s internal bean factory after its standard</span></span>
<span class="line"><span style="color:#8B949E;">   * initialization. All bean definitions will have been loaded, but no beans</span></span>
<span class="line"><span style="color:#8B949E;">   * will have been instantiated yet. This allows for overriding or adding</span></span>
<span class="line"><span style="color:#8B949E;">   * properties even to eager-initializing beans.</span></span>
<span class="line"><span style="color:#8B949E;">   * </span><span style="color:#FF7B72;">@param</span><span style="color:#8B949E;"> </span><span style="color:#FFA657;">beanFactory</span><span style="color:#8B949E;"> the bean factory used by the application context</span></span>
<span class="line"><span style="color:#8B949E;">   * </span><span style="color:#FF7B72;">@throws</span><span style="color:#8B949E;"> </span><span style="color:#FFA657;">org.springframework.beans.BeansException</span><span style="color:#8B949E;"> in case of errors</span></span>
<span class="line"><span style="color:#8B949E;">   */</span></span>
<span class="line"><span style="color:#C9D1D9;">  </span><span style="color:#FF7B72;">void</span><span style="color:#C9D1D9;"> </span><span style="color:#D2A8FF;">postProcessBeanFactory</span><span style="color:#C9D1D9;">(ConfigurableListableBeanFactory </span><span style="color:#FFA657;">beanFactory</span><span style="color:#C9D1D9;">) </span><span style="color:#FF7B72;">throws</span><span style="color:#C9D1D9;"> BeansException;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>我们可以通过实现<code>BeanFactoryPostProcessor</code>接口，获取<code>BeanFactory</code>，操作<code>BeanFactory</code>对象，修改<code>BeanDefinition</code>，但不要去实例化bean。</p><p><strong>todo</strong>：</p><ol><li><p>springboot <code>ApplicationContext</code> 类继承结构，各接口和抽象模板类作用</p></li><li><p><code>BeanDefinition</code> 如何被自动装配？</p></li><li><p>ioc 容器初始化流程</p></li></ol><h1 id="ioc容器的创建" tabindex="-1"><a class="header-anchor" href="#ioc容器的创建" aria-hidden="true">#</a> IOC容器的创建</h1><h2 id="beanfactory解析" tabindex="-1"><a class="header-anchor" href="#beanfactory解析" aria-hidden="true">#</a> BeanFactory解析</h2><p>BeanFactory 接口的继承关系：</p><p><img src="http://img.stormbuf.top/20210720115542.png" alt=""></p><p>简单描述这些接口：</p><ul><li><p><code>org.springframework.beans.factory.BeanFactory</code>，Spring IoC 容器最基础的接口，提供依赖查找<strong>单个</strong> Bean 的功能</p></li><li><p><code>org.springframework.beans.factory.ListableBeanFactory</code>，继承 BeanFactory 接口，提供依赖查找<strong>多个</strong> Bean 的功能</p></li><li><p><code>org.springframework.beans.factory.HierarchicalBeanFactory</code>，继承 BeanFactory 接口，提供获取父 BeanFactory 的功能，具有<strong>层次性</strong></p></li><li><p><code>org.springframework.beans.factory.config.ConfigurableBeanFactory</code>，继承 HierarchicalBeanFactory 接口，提供可操作内部相关组件的功能，具有<strong>可配置性</strong></p></li><li><p><code>org.springframework.beans.factory.config.AutowireCapableBeanFactory</code>，继承 BeanFactory 接口，提供可注入的功能，支持<strong>依赖注入</strong></p></li><li><p><code>org.springframework.beans.factory.config.ConfigurableListableBeanFactory</code>，继承上面所有接口，综合所有特性，还提供可提前初始化所有单例 Bean 的功能 通过这些接口的名称可以大致了解其用意，接下来我们来看看它们的实现类的继承关系</p></li></ul><p><img src="http://img.stormbuf.top/DefaultListableBeanFactory.png" alt=""></p><p>简单描述这些实现类：</p><ul><li><p><code>org.springframework.beans.factory.support.AbstractBeanFactory</code> 抽象类，实现 ConfigurableBeanFactory 接口，基础实现类，Bean 的创建过程交由子类实现</p></li><li><p><code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory</code> 抽象类，继承 AbstractBeanFactory，实现 AutowireCapableBeanFactory 接口，完成 Bean 的创建</p></li><li><p><code>org.springframework.beans.factory.support.DefaultListableBeanFactory</code>，Spring 底层 IoC 容器，依赖注入的底层实现 其他的接口和类和 BeanDefinition 注册中心，别名注册中心，单例 Bean 注册中心相关；右下角的 ApplicationContext 与 Spring 应用上下文有关。</p></li></ul><h2 id="applicationcontext-解析" tabindex="-1"><a class="header-anchor" href="#applicationcontext-解析" aria-hidden="true">#</a> ApplicationContext 解析</h2><p>ApplicationContext 就是 Spring 应用上下文，它不仅继承了 BeanFactory 体系，还提供更加高级的功能，更加适用于我们的正式应用环境。如以下几个功能：</p><ul><li><p>继承 MessageSource，提供国际化的标准访问策略</p></li><li><p>继承 ApplicationEventPublisher ，提供强大的事件机制</p></li><li><p>扩展 ResourceLoader，可以用来加载多个 Resource，可以灵活访问不同的资源</p></li><li><p>对 Web 应用的支持</p></li></ul><h3 id="applicationcontext-体系结构" tabindex="-1"><a class="header-anchor" href="#applicationcontext-体系结构" aria-hidden="true">#</a> ApplicationContext 体系结构</h3><p>先来看看 ApplicationContext 接口的继承关系</p><p><img src="http://img.stormbuf.top/20210720174450.png" alt=""></p><p>可以看到 ApplicationContext 除了继承 BeanFactory 接口以外，还继承了 MessageSource、ApplicationEventPublisher、ResourceLoader 等接口</p><p>简单描述几个接口：</p><ul><li><p><code>org.springframework.core.io.ResourceLoader</code>，资源加载接口，用于访问不同的资源</p></li><li><p><code>org.springframework.context.ApplicationEventPublisher</code>，事件发布器接口，支持发布事件</p></li><li><p><code>org.springframework.context.MessageSource</code>，消息资源接口，提供国际化的标准访问策略</p></li><li><p><code>org.springframework.core.env.EnvironmentCapable</code>，环境暴露接口，Spring 应用上下文支持多环境的配置</p></li><li><p><code>org.springframework.context.ApplicationContext</code>，Spring 应用上下文，仅可读</p></li><li><p><code>org.springframework.context.ConfigurableApplicationContext</code>，Spring 应用上下文，支持配置相关属性</p></li></ul><p>接下来我们来看看它们的实现类的继承关系（部分）</p><p><img src="http://img.stormbuf.top/20210720174620.png" alt=""></p><p>简单描述上面几个关键的类：</p><ul><li><p><code>org.springframework.context.support.AbstractApplicationContext</code>，Spring 应用上下文的抽象类，实现了大部分功能，提供骨架方法交由子类去实现</p></li><li><p><code>org.springframework.web.context.ConfigurableWebApplicationContext</code>，可配置的 Spring 应用上下文接口，支持 Web 应用</p></li><li><p><code>org.springframework.context.support.AbstractRefreshableConfigApplicationContext</code>，支持设置 XML 文件</p></li><li><p><code>org.springframework.web.context.support.AbstractRefreshableWebApplicationContext</code>，支持 Web 应用</p></li><li><p><code>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</code>，支持 Web 应用，可以设置 XML 文件，并可以扫描注解下面的 Bean</p></li><li><p><code>org.springframework.context.annotation.AnnotationConfigApplicationContext</code>，支持扫描注解下面的 Bean</p></li><li><p><code>org.springframework.web.context.support.ClassPathXmlApplicationContext</code>，支持设置 XML 文件，也可以从 classpath 下面扫描相关资源</p></li></ul><p>ApplicationContext 的子类比较多，主要根据支持 Web、支持注解、支持 XML 文件三个功能进行区分，我们大致了解每个实现类的作用即可。其中基本的实现都是在 <strong>AbstractApplicationContext</strong> 这个抽象类中完成的，在它的 <code>refresh()</code> 方法体现了 Spring 应用上下文的生命周期。<code>AbstractApplicationContext#refresh()</code> 这个方法可以说是 Spring 应用上下文的准备阶段，在使用 Spring 时该方法会被调用。</p><h2 id="【核心】refresh-方法" tabindex="-1"><a class="header-anchor" href="#【核心】refresh-方法" aria-hidden="true">#</a> 【核心】refresh 方法</h2><div class="language-java ext-java line-numbers-mode"><pre class="shiki" style="background-color:#0d1117;"><code><span class="line"><span style="color:#C9D1D9;">@</span><span style="color:#FF7B72;">Override</span></span>
<span class="line"><span style="color:#C9D1D9;">  </span><span style="color:#FF7B72;">public</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">void</span><span style="color:#C9D1D9;"> </span><span style="color:#D2A8FF;">refresh</span><span style="color:#C9D1D9;">() throws BeansException, IllegalStateException {</span></span>
<span class="line"><span style="color:#C9D1D9;">    </span><span style="color:#8B949E;">// &lt;1&gt; 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span></span>
<span class="line"><span style="color:#C9D1D9;">    </span><span style="color:#FF7B72;">synchronized</span><span style="color:#C9D1D9;"> (</span><span style="color:#79C0FF;">this</span><span style="color:#C9D1D9;">.startupShutdownMonitor) {</span></span>
<span class="line"><span style="color:#C9D1D9;">      </span></span>
<span class="line"><span style="color:#C9D1D9;">      </span><span style="color:#8B949E;">// &lt;2&gt; 刷新上下文环境的准备工作，记录下容器的启动时间、标记&#39;已启动&#39;状态、对上下文环境属性进行校验</span></span>
<span class="line"><span style="color:#C9D1D9;">      </span><span style="color:#D2A8FF;">prepareRefresh</span><span style="color:#C9D1D9;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">      </span><span style="color:#8B949E;">// &lt;3&gt; 创建并初始化一个 BeanFactory 对象 `beanFactory`，会加载出对应的 BeanDefinition 元信息们</span></span>
<span class="line"><span style="color:#C9D1D9;">      ConfigurableListableBeanFactory</span><span style="color:#FFA657;"> </span><span style="color:#C9D1D9;">beanFactory</span><span style="color:#FFA657;"> </span><span style="color:#FF7B72;">=</span><span style="color:#C9D1D9;"> </span><span style="color:#D2A8FF;">obtainFreshBeanFactory</span><span style="color:#C9D1D9;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">      </span><span style="color:#8B949E;">// &lt;4&gt; 为 `beanFactory` 进行一些准备工作，例如添加几个 BeanPostProcessor，手动注册几个特殊的 Bean</span></span>
<span class="line"><span style="color:#C9D1D9;">      </span><span style="color:#D2A8FF;">prepareBeanFactory</span><span style="color:#C9D1D9;">(beanFactory);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">      </span><span style="color:#FF7B72;">try</span><span style="color:#C9D1D9;"> {</span></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#8B949E;">// &lt;5&gt; 对 `beanFactory` 在进行一些后期的加工，交由子类进行扩展</span></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#D2A8FF;">postProcessBeanFactory</span><span style="color:#C9D1D9;">(beanFactory);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#8B949E;">// &lt;6&gt; 执行 BeanFactoryPostProcessor 处理器，包含 BeanDefinitionRegistryPostProcessor 处理器</span></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#D2A8FF;">invokeBeanFactoryPostProcessors</span><span style="color:#C9D1D9;">(beanFactory);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#8B949E;">// &lt;7&gt; 对 BeanPostProcessor 处理器进行初始化，并添加至 BeanFactory 中</span></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#D2A8FF;">registerBeanPostProcessors</span><span style="color:#C9D1D9;">(beanFactory);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#8B949E;">// &lt;8&gt; 设置上下文的 MessageSource 对象</span></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#D2A8FF;">initMessageSource</span><span style="color:#C9D1D9;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#8B949E;">// &lt;9&gt; 设置上下文的 ApplicationEventMulticaster 对象，上下文事件广播器</span></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#D2A8FF;">initApplicationEventMulticaster</span><span style="color:#C9D1D9;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#8B949E;">// &lt;10&gt; 刷新上下文时再进行一些初始化工作，交由子类进行扩展</span></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#D2A8FF;">onRefresh</span><span style="color:#C9D1D9;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#8B949E;">// &lt;11&gt; 将所有 ApplicationListener 监听器添加至 `applicationEventMulticaster` 事件广播器，如果已有事件则进行广播</span></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#D2A8FF;">registerListeners</span><span style="color:#C9D1D9;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#8B949E;">// &lt;12&gt; 设置 ConversionService 类型转换器，**初始化**所有还未初始化的 Bean（不是抽象、单例模式、不是懒加载方式）</span></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#D2A8FF;">finishBeanFactoryInitialization</span><span style="color:#C9D1D9;">(beanFactory);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#8B949E;">// &lt;13&gt; 刷新上下文的最后一步工作，会发布 ContextRefreshedEvent 上下文完成刷新事件</span></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#D2A8FF;">finishRefresh</span><span style="color:#C9D1D9;">();</span></span>
<span class="line"><span style="color:#C9D1D9;">      }</span></span>
<span class="line"><span style="color:#C9D1D9;">      </span><span style="color:#8B949E;">// &lt;14&gt; 如果上面过程出现 BeansException 异常</span></span>
<span class="line"><span style="color:#C9D1D9;">      </span><span style="color:#FF7B72;">catch</span><span style="color:#C9D1D9;"> (BeansException </span><span style="color:#FFA657;">ex</span><span style="color:#C9D1D9;">) {</span></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#FF7B72;">if</span><span style="color:#C9D1D9;"> (logger.</span><span style="color:#D2A8FF;">isWarnEnabled</span><span style="color:#C9D1D9;">()) {</span></span>
<span class="line"><span style="color:#C9D1D9;">          logger.</span><span style="color:#D2A8FF;">warn</span><span style="color:#C9D1D9;">(</span><span style="color:#A5D6FF;">&quot;Exception encountered during context initialization - &quot;</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">+</span></span>
<span class="line"><span style="color:#C9D1D9;">              </span><span style="color:#A5D6FF;">&quot;cancelling refresh attempt: &quot;</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">+</span><span style="color:#C9D1D9;"> ex);</span></span>
<span class="line"><span style="color:#C9D1D9;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#8B949E;">// &lt;14.1&gt; “销毁” 已注册的单例 Bean</span></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#D2A8FF;">destroyBeans</span><span style="color:#C9D1D9;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#8B949E;">// &lt;14.2&gt; 设置上下文的 `active` 状态为 `false`</span></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#D2A8FF;">cancelRefresh</span><span style="color:#C9D1D9;">(ex);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#8B949E;">// &lt;14.3&gt; 抛出异常</span></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#FF7B72;">throw</span><span style="color:#C9D1D9;"> ex;</span></span>
<span class="line"><span style="color:#C9D1D9;">      }</span></span>
<span class="line"><span style="color:#C9D1D9;">      </span><span style="color:#8B949E;">// &lt;15&gt; `finally` 代码块</span></span>
<span class="line"><span style="color:#C9D1D9;">      </span><span style="color:#FF7B72;">finally</span><span style="color:#C9D1D9;"> {</span></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#8B949E;">// Reset common introspection caches in Spring&#39;s core, since we</span></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#8B949E;">// might not ever need metadata for singleton beans anymore...</span></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#8B949E;">// 清除相关缓存，例如通过反射机制缓存的 Method 和 Field 对象，缓存的注解元数据，缓存的泛型类型对象，缓存的类加载器</span></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#D2A8FF;">resetCommonCaches</span><span style="color:#C9D1D9;">();</span></span>
<span class="line"><span style="color:#C9D1D9;">      }</span></span>
<span class="line"><span style="color:#C9D1D9;">    }</span></span>
<span class="line"><span style="color:#C9D1D9;">  }</span></span>
<span class="line"></span></code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br></div></div><p><strong><code>finishBeanFactoryInitialization(beanFactory)</code></strong>** 方法初始化了所有的非懒加载的单例bean。**</p><h2 id="beandefinition-解析" tabindex="-1"><a class="header-anchor" href="#beandefinition-解析" aria-hidden="true">#</a> BeanDefinition 解析</h2><p>BeanDefinition 介绍</p><h3 id="面向注解的解析" tabindex="-1"><a class="header-anchor" href="#面向注解的解析" aria-hidden="true">#</a> 面向注解的解析</h3><p>核心类是 <code>org.springframework.context.annotation.ClassPathBeanDefinitionScanner</code>。</p><ol><li><p>该类在创建时设置了基于<code>@Component</code> 注解的过滤器。</p></li><li><p>调用<code>doScan(String... basePackages)</code> 方法，根据过滤器扫描出包路径（入参的就是包路径）下符合条件 .class文件，生成 <code>BeanDefinition</code>。</p></li><li><p>将 <code>BeanDefinition </code>封装成 <code>BeanDefinitionHolder </code>对象（这里多了一个 <code>beanName</code>），并注册到<code>BeanDefinitionRegistry</code>中</p></li><li><p>如果代理模式是 <strong>TARGET_CLASS</strong>，则再创建一个 <code>BeanDefinition </code>代理对象（重新设置了相关属性），原始 <code>BeanDefinition </code>已注册（该处与<strong>AOP</strong>相关）</p></li></ol><h2 id="spring-扩展点解析" tabindex="-1"><a class="header-anchor" href="#spring-扩展点解析" aria-hidden="true">#</a> Spring 扩展点解析</h2><h2 id="广播机制" tabindex="-1"><a class="header-anchor" href="#广播机制" aria-hidden="true">#</a> 广播机制</h2><h1 id="bean-的创建和生命周期" tabindex="-1"><a class="header-anchor" href="#bean-的创建和生命周期" aria-hidden="true">#</a> bean 的创建和生命周期</h1><p>创建 Bean 的过程如下：</p><ul><li><p>Class 对象加载阶段</p></li><li><p>实例化前阶段（如果返回了一个对象则直接返回，不会进行下面的阶段）</p></li><li><p>实例化阶段</p></li><li><p>实例化后阶段</p></li><li><p>提前暴露单例 Bean（循环依赖处理的关键）</p></li><li><p>属性填充阶段</p></li><li><p>Aware 接口回调阶段</p></li><li><p>初始化前阶段</p></li><li><p>初始化阶段</p></li><li><p>初始化后阶段</p></li></ul><p><img src="http://img.stormbuf.top/java0-1559531915.jpg" alt=""></p><h2 id="dogetbean-方法" tabindex="-1"><a class="header-anchor" href="#dogetbean-方法" aria-hidden="true">#</a> doGetBean 方法</h2><p><code>doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType, @Nullable final Object[] args, boolean typeCheckOnly)</code></p><p>该方法是获取与创建bean的核心方法。</p><h2 id="createbean" tabindex="-1"><a class="header-anchor" href="#createbean" aria-hidden="true">#</a> createBean</h2><p><code>AbstractAutowireCapableBeanFactory#createBean(String, RootBeanDefinition, Object[])</code></p><p>该方法是创建bean的核心方法。由<code>doGetBean</code>调用。</p><p><code>createBean</code>通过调用<code>doCreateBean</code>方法创建bean。</p><p>过程大致如下：</p><ol><li>获取 <code>mbd</code> 对应的 Class 对象，确保当前 Bean 能够被创建出来，调用 <code>resolveBeanClass(...)</code> 方法</li><li>对所有的 MethodOverride 进行<strong>验证</strong>和<strong>准备</strong>工作（确保存在对应的方法，并设置为不能重复加载）</li><li><strong>实例化前阶段</strong>在实例化前进行相关处理，会先调用所有 InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation 注意，如果这里返回对象不是 <code>null</code> 的话，不会继续往下执行原本初始化操作，<strong>直接返回</strong>，也就是说这个方法返回的是最终实例对象 可以通过这种方式<strong>提前返回</strong>一个代理对象，例如 AOP 的实现，或者 RPC 远程调用的实现（因为本地类没有远程能力，可以通过这种方式进行拦截）</li><li>创建 Bean 对象 <code>beanInstance</code>，如果上一步没有返回代理对象，就只能走常规的路线进行 Bean 的创建了，调用 <code>doCreateBean(...)</code> 方法</li><li>将 <code>beanInstance</code> 返回 可以看到这个方法中并没有开始真正 Bean 的创建，在这个方法的第 <code>4</code> 步会调用 <code>doCreateBean(...)</code> 方法创建 Bean</li></ol><h2 id="docreatebean" tabindex="-1"><a class="header-anchor" href="#docreatebean" aria-hidden="true">#</a> doCreateBean</h2><p>过程大致如下：</p><ol><li>Bean 的<strong>实例化阶段</strong>，会将 Bean 的实例对象封装成 BeanWrapperImpl 包装对象</li><li>如果是单例模式，则先尝试从 <code>factoryBeanInstanceCache</code> 缓存中获取实例对象，并从缓存中移除</li><li>使用合适的实例化策略来创建 Bean 的实例：工厂方法、构造函数自动注入、简单初始化，主要是将 BeanDefinition 转换为 BeanWrapper 对象 调用 <code>createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</code> 方法</li><li>获取包装的实例对象 <code>bean </code>4. 获取包装的实例对象的类型 <code>beanType </code>2. 对 <code>RootBeanDefinition</code>（合并后）进行<strong>加工处理</strong>1. 如果该 <code>RootBeanDefinition </code>没有处理过，则进行下面的处理</li><li>调用所有的 <code>MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition</code>，这个过程非常重要，例如 Spring 内有下面两个处理器：</li></ol><ul><li><p><code>AutowiredAnnotationBeanPostProcessor</code>，会先解析出 <code>@Autowired</code> 和 <code>@Value</code> 注解标注的属性的注入元信息，后续进行依赖注入</p></li><li><p><code>CommonAnnotationBeanPostProcessor</code>，会先解析出 <code>@Resource</code> 注解标注的属性的注入元信息，后续进行依赖注入，它也会找到 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解标注的方法，并构建一个 <code>LifecycleMetadata </code>对象，用于后续生命周期中的初始化和销毁</p></li></ul><ol start="3"><li>设置该 <code>RootBeanDefinition </code>被处理过，避免重复处理</li><li><strong>提前暴露</strong>这个 <code>bean</code>，如果可以的话，目的是解决单例模式 Bean 的循环依赖注入</li><li>判断是否可以提前暴露，满足三个条件：单例模式、允许循环依赖（默认为 true）、当前单例 bean 正在被创建，在前面已经标记过</li><li>创建一个 <code>ObjectFactory </code>实现类，用于返回当前正在被创建的 <code>bean</code>，提前暴露，保存在 <code>singletonFactories</code> （<strong>三级 Map</strong>）缓存中</li></ol><hr><p>接下来开始初始化上面的 <code>bean</code> 实例对象，会先创建一个 <code>Object exposedObject</code> 等于 <code>bean</code> （引用） 4. 对 <code>bean</code> 进行<strong>属性填充</strong>，注入对应的属性值，调用 <code>populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</code> 方法 5. <strong>初始化</strong>这个 <code>exposedObject</code>，调用其初始化方法，调用 <code>initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd)</code> 方法</p><hr><ol start="6"><li><strong>循环依赖注入的检查</strong>1. 获取当前正在创建的 <code>beanName</code> 被依赖注入的早期引用，调用 <code>DefaultSingletonBeanRegistry#getSingleton(String beanName, boolean allowEarlyReference)</code> 方法。注意，这里有一个入参是 <code>false</code>，不会调用上面第 <code>3</code> 步的 <code>ObjectFactory </code>实现类，也就是说当前 <code>bean</code> 如果出现循环依赖注入，这里才能获取到提前暴露的引用</li><li>如果出现了循环依赖注入，则进行接下来的检查工作</li><li>如果 <code>exposedObject</code> 没有在初始化阶段中被改变，也就是没有被增强，则使用提前暴露的那个引用</li><li>否则，<code>exposedObject</code> 已经不是被别的 Bean 依赖注入的那个 Bean，如果依赖当前 <code>beanName</code> 的 Bean（通过 <code>depends-on</code> 配置）已经被创建，则抛出异常</li><li>为当前 <code>bean</code> 注册 <code>DisposableBeanAdapter</code>（如果需要的话），用于 Bean 生命周期中的销毁阶段</li><li>返回创建好的 <code>exposedObject</code> 对象 概括：</li></ol><ul><li><p>首先获取对应的 Class 对象，创建一个实例对象</p></li><li><p>对这个实例对象进行属性填充</p></li><li><p>调用这个实例对象的初始化方法</p></li></ul><hr><h2 id="createbeaninstance" tabindex="-1"><a class="header-anchor" href="#createbeaninstance" aria-hidden="true">#</a> createBeanInstance</h2><p>在 <code>doCreateBean</code> 被调用，创建一个 Bean 的实例对象，并将 Bean 的实例对象封装成 <code>BeanWrapperImpl</code>包装对象返回。</p><p>过程大致如下：</p><ol><li><p>获取 <code>beanName</code> 对应的 Class 对象</p></li><li><p>如果存在 Supplier 实例化回调接口，则使用给定的回调方法创建一个实例对象</p></li><li><p>如果配置了 <code>factory-method</code> 工厂方法，则调用该方法来创建一个实例对象，通过 @Bean 标注的方法会通过这里进行创建</p></li></ol><hr><p>如果上面两种情况都不是，那么就进行接下来正常创建 Bean 实例的一个过程</p><ol><li><p>判断这个 RootBeanDefinition 的构造方法是否已经被解析出来了，因为找到最匹配的构造方法比较繁琐，找到后会设置到 RootBeanDefinition 中，避免重复这个过程</p></li><li><p>RootBeanDefinition 的 <code>resolvedConstructorOrFactoryMethod</code> 是否不为空，不为空表示构造方法已经解析出来了</p></li><li><p>构造方法已经解析出来了，则判断它的 <code>constructorArgumentsResolved</code> 是否不为空，不为空表示有入参，需要先获取到对应的入参（构造器注入）</p></li><li><p>如果最匹配的构造方法已解析出来</p></li><li><p>如果这个构造方法有入参，则找到最匹配的构造方法，这里会拿到已经被解析出来的这个方法，并找到入参（构造器注入），然后调用该方法返回一个实例对象（反射机制）</p></li><li><p>否则，没有入参，直接调用解析出来构造方法，返回一个实例对象（反射机制）</p></li><li><p>如果最匹配的构造方法还没开始解析，那么需要找到一个最匹配的构造方法，然后创建一个实例对象</p></li><li><p>先尝试通过 SmartInstantiationAwareBeanPostProcessor 处理器找到一些合适的构造方法，保存在 <code>ctors</code> 中</p></li><li><p>是否满足下面其中一个条件：<code>ctors</code> 不为空、构造器注入模式、定义了构造方法的入参、当前方法指定了入参，</p></li></ol><pre><code>则找到最匹配的构造方法，如果 `ctors` 不为空，会从这里面找一个最匹配的，并找到入参（构造器注入），然后调用该方法返回一个实例对象（反射机制）
</code></pre><ol><li><p>如果第 <code>6</code> 步还不满足，那么尝试从 RootBeanDefinition 中获取优先的构造方法</p></li><li><p>如果存在优先的构造方法，则从里面找到最匹配的一个，并找到入参（构造器注入），然后调用该方法返回一个实例对象（反射机制）</p></li><li><p>如果上面多种情况都不满足，那只能使用兜底方法了，直接调用默认构造方法返回一个实例对象（反射机制）</p></li></ol><hr><p>整个的实例化过程非常的复杂，接下来进行概括：</p><ul><li><p>先拿到对应 Class 对象</p></li><li><p>如果设置了 Supplier 实例化回调接口，则通过该回调接口获取实例对象</p></li><li><p>如果配置了通过 <code>factory-method</code> 工厂方法获取实例对象，则通过这个方法创建实例对象，@Bean 标注的方法也是通过这里创建实例对象，方法入参会依赖注入</p></li><li><p>找到最匹配的一个构造方法，并找到对应的入参（构造器注入），通过调用该方法返回一个实例对象</p></li><li><p>兜底方法，调用默认构造方法创建一个实例对象</p></li></ul><p>BeanWrapperImpl 承担的角色：</p><ol><li><p>Bean 实例的包装</p></li><li><p><code>org.springframework.beans.PropertyAccessor</code> 属性编辑器</p></li><li><p><code>org.springframework.beans.PropertyEditorRegistry</code> 属性编辑器注册表</p></li><li><p>类型转换器</p></li></ol><h2 id="populatebean" tabindex="-1"><a class="header-anchor" href="#populatebean" aria-hidden="true">#</a> populateBean</h2><p>用作<strong>属性填充</strong>。</p><h2 id="三级缓存" tabindex="-1"><a class="header-anchor" href="#三级缓存" aria-hidden="true">#</a> 三级缓存</h2><p>作用：解决属性注入和Setter注入的循环依赖，无法解决构造器注入的循环依赖。</p><p>说明：这里的循环依赖指的是<strong>单例模式</strong>下的 Bean <strong>字段注入</strong>时出现的循环依赖。<strong>构造器注入</strong>对于 Spring 无法自动解决（应该考虑代码设计是否有问题），可通过延迟初始化来处理。Spring 只解决<strong>单例模式</strong>下的循环依赖。</p><p>在 Spring 底层 IoC 容器 BeanFactory 中处理循环依赖的方法主要借助于以下 <code>3</code> 个 Map 集合：</p><ol><li><p><code>singletonObjects</code>（一级 Map），里面保存了所有已经初始化好的单例 Bean，也就是会保存 Spring IoC 容器中所有单例的 Spring Bean；</p></li><li><p><code>earlySingletonObjects</code>（二级 Map），里面会保存从 <strong>三级 Map</strong> 获取到的正在初始化的 Bean</p></li><li><p><code>singletonFactories</code>（三级 Map），里面保存了正在初始化的 Bean 对应的 ObjectFactory 实现类，调用其 getObject() 方法返回正在初始化的 Bean 对象（仅实例化还没完全初始化好），如果存在则将获取到的 Bean 对象并保存至 <strong>二级 Map</strong>，同时从当前 <strong>三级 Map</strong> 移除该 ObjectFactory 实现类。</p></li></ol><p>当通过 getBean 依赖查找时会首先依次从上面三个 Map 获取，存在则返回，不存在则进行初始化，这三个 Map 是处理循环依赖的关键。</p><p>例如两个 Bean 出现循环依赖，A 依赖 B，B 依赖 A；当我们去依赖查找 A，在实例化后初始化前会先生成一个 ObjectFactory 对象（可获取当前正在初始化 A）保存在上面的 <code>singletonFactories</code> 中，初始化的过程需注入 B；接下来去查找 B，初始 B 的时候又要去注入 A，又去查找 A ，由于可以通过 <code>singletonFactories</code> 直接拿到正在初始化的 A，那么就可以完成 B 的初始化，最后也完成 A 的初始化，这样就避免出现循环依赖。</p><blockquote><p>B（也依赖 A） -&gt; C -&gt; A，当你获取 A 这个 Bean 时，后续 B 和 C 都要注入 A，没有上面的 <strong>二级 Map</strong>的话，<strong>三级 Map</strong> 保存的 ObjectFactory 实现类会被调用两次，会重复处理，可能出现问题，这样做在性能上也有所提升 <strong>问题二</strong>：为什么不直接调用这个 ObjectFactory#getObject() 方法放入 <strong>二级Map</strong> 中，而需要上面的 <strong>三级 Map</strong>？ 对于不涉及到 AOP 的 Bean 确实可以不需要 <code>singletonFactories</code>（三级 Map），但是 Spring AOP 就是 Spring 体系中的一员，如果没有<code>singletonFactories</code>（三级 Map），意味着 Bean 在实例化后就要完成 AOP 代理，这样违背了 Spring 的设计原则。Spring 是通过 <code>AnnotationAwareAspectJAutoProxyCreator</code> 这个后置处理器在完全创建好 Bean 后来完成 AOP 代理，而不是在实例化后就立马进行 AOP 代理。如果出现了循环依赖，那没有办法，只有给 Bean 先创建代理对象，但是在没有出现循环依赖的情况下，设计之初就是让 Bean 在完全创建好后才完成 AOP 代理。</p></blockquote><blockquote><p>提示：<code>AnnotationAwareAspectJAutoProxyCreator</code> 是一个 <code>SmartInstantiationAwareBeanPostProcessor</code> 后置处理器，在它的 getEarlyBeanReference(..) 方法中可以创建代理对象。所以说对于上面的<strong>问题二</strong>，如果出现了循环依赖，如果是一个 AOP 代理对象，那只能给 Bean 先创建代理对象，设计之初就是让 Bean 在完全创建好后才完成 AOP 代理。</p></blockquote><blockquote><p>为什么 Spring 的设计是让 Bean 在完全创建好后才完成 AOP 代理？</p></blockquote><p>因为创建的代理对象需要关联目标对象，在拦截处理的过程中需要根据目标对象执行被拦截的方法，所以这个目标对象最好是一个“成熟态”，而不是仅实例化还未初始化的一个对象。</p><h1 id="aop" tabindex="-1"><a class="header-anchor" href="#aop" aria-hidden="true">#</a> aop</h1><p>Bean 的加载过程，整个过程中会调用相应的 BeanPostProcessor 对正在创建 Bean 进行处理，例如：</p><ol><li><p>在 Bean 的实例化前，会调用 <code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation(..)</code> 方法进行处理</p></li><li><p>在 Bean 出现循环依赖的情况下，会调用 <code>SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference(..)</code> 方法对提前暴露的 Bean 进行处理</p></li><li><p>在 Bean 初始化后，会调用 <code>BeanPostProcessor#postProcessAfterInitialization(..)</code> 方法对初始化好的 Bean 进行处理</p></li></ol><p>Spring AOP 则是通过上面三个切入点进行创建代理对象，实现<strong>自动代理</strong>。</p><ul><li><p>在 Spring AOP 中主要是通过第 <code>3</code> 种 BeanPostProcessor 创建代理对象，在 Bean 初始化后，也就是一个“成熟态”，然后再尝试是否创建一个代理对象；</p></li><li><p>第 <code>2</code> 种方式是为了解决 Bean 循环依赖的问题，虽然 Bean 仅实例化还未初始化，但是出现了循环依赖，不得不在此时创建一个代理对象；</p></li><li><p>第 <code>1</code> 种方式是在 Bean 还没有实例化的时候就提前创建一个代理对象（创建了则不会继续后续的 Bean 的创建过程），例如 RPC 远程调用的实现，因为本地类没有远程能力，可以通过这种方式进行拦截。</p></li></ul><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.edc637f8.js" defer></script>
  </body>
</html>
