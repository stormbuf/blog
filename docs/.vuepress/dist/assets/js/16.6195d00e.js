(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{451:function(t,a,n){"use strict";n.r(a);var e=n(33),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"spring"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring"}},[t._v("#")]),t._v(" spring")]),t._v(" "),n("h1",{attrs:{id:"beanfactory"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#beanfactory"}},[t._v("#")]),t._v(" BeanFactory")]),t._v(" "),n("h2",{attrs:{id:"beanfactorypostprocessor-接口"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#beanfactorypostprocessor-接口"}},[t._v("#")]),t._v(" BeanFactoryPostProcessor 接口")]),t._v(" "),n("p",[n("code",[t._v("BeanFactoryPostProcessor")]),t._v("是一个函数式接口，里面只有一个方法：")]),t._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@FunctionalInterface")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BeanFactoryPostProcessor")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n   * Modify the application context's internal bean factory after its standard\n   * initialization. All bean definitions will have been loaded, but no beans\n   * will have been instantiated yet. This allows for overriding or adding\n   * properties even to eager-initializing beans.\n   * @param beanFactory the bean factory used by the application context\n   * @throws org.springframework.beans.BeansException in case of errors\n   */")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("postProcessBeanFactory")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ConfigurableListableBeanFactory")]),t._v(" beanFactory"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throws")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BeansException")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("我们可以通过实现"),n("code",[t._v("BeanFactoryPostProcessor")]),t._v("接口，获取"),n("code",[t._v("BeanFactory")]),t._v("，操作"),n("code",[t._v("BeanFactory")]),t._v("对象，修改"),n("code",[t._v("BeanDefinition")]),t._v("，但不要去实例化bean。")]),t._v(" "),n("p",[n("strong",[t._v("todo")]),t._v("：")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("springboot "),n("code",[t._v("ApplicationContext")]),t._v(" 类继承结构，各接口和抽象模板类作用")])]),t._v(" "),n("li",[n("p",[n("code",[t._v("BeanDefinition")]),t._v(" 如何被自动装配？")])]),t._v(" "),n("li",[n("p",[t._v("ioc 容器初始化流程")])])]),t._v(" "),n("h1",{attrs:{id:"ioc容器的创建"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ioc容器的创建"}},[t._v("#")]),t._v(" IOC容器的创建")]),t._v(" "),n("h2",{attrs:{id:"beanfactory解析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#beanfactory解析"}},[t._v("#")]),t._v(" BeanFactory解析")]),t._v(" "),n("p",[t._v("BeanFactory 接口的继承关系：")]),t._v(" "),n("p",[n("img",{attrs:{src:"http://img.stormbuf.top/20210720115542.png",alt:""}})]),t._v(" "),n("p",[t._v("简单描述这些接口：")]),t._v(" "),n("ul",[n("li",[n("p",[n("code",[t._v("org.springframework.beans.factory.BeanFactory")]),t._v("，Spring IoC 容器最基础的接口，提供依赖查找"),n("strong",[t._v("单个")]),t._v(" Bean 的功能")])]),t._v(" "),n("li",[n("p",[n("code",[t._v("org.springframework.beans.factory.ListableBeanFactory")]),t._v("，继承 BeanFactory 接口，提供依赖查找"),n("strong",[t._v("多个")]),t._v(" Bean 的功能")])]),t._v(" "),n("li",[n("p",[n("code",[t._v("org.springframework.beans.factory.HierarchicalBeanFactory")]),t._v("，继承 BeanFactory 接口，提供获取父 BeanFactory 的功能，具有"),n("strong",[t._v("层次性")])])]),t._v(" "),n("li",[n("p",[n("code",[t._v("org.springframework.beans.factory.config.ConfigurableBeanFactory")]),t._v("，继承 HierarchicalBeanFactory 接口，提供可操作内部相关组件的功能，具有"),n("strong",[t._v("可配置性")])])]),t._v(" "),n("li",[n("p",[n("code",[t._v("org.springframework.beans.factory.config.AutowireCapableBeanFactory")]),t._v("，继承 BeanFactory 接口，提供可注入的功能，支持"),n("strong",[t._v("依赖注入")])])]),t._v(" "),n("li",[n("p",[n("code",[t._v("org.springframework.beans.factory.config.ConfigurableListableBeanFactory")]),t._v("，继承上面所有接口，综合所有特性，还提供可提前初始化所有单例 Bean 的功能\n通过这些接口的名称可以大致了解其用意，接下来我们来看看它们的实现类的继承关系")])])]),t._v(" "),n("p",[n("img",{attrs:{src:"http://img.stormbuf.top/DefaultListableBeanFactory.png",alt:""}})]),t._v(" "),n("p",[t._v("简单描述这些实现类：")]),t._v(" "),n("ul",[n("li",[n("p",[n("code",[t._v("org.springframework.beans.factory.support.AbstractBeanFactory")]),t._v(" 抽象类，实现 ConfigurableBeanFactory 接口，基础实现类，Bean 的创建过程交由子类实现")])]),t._v(" "),n("li",[n("p",[n("code",[t._v("org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory")]),t._v(" 抽象类，继承 AbstractBeanFactory，实现 AutowireCapableBeanFactory 接口，完成 Bean 的创建")])]),t._v(" "),n("li",[n("p",[n("code",[t._v("org.springframework.beans.factory.support.DefaultListableBeanFactory")]),t._v("，Spring 底层 IoC 容器，依赖注入的底层实现\n其他的接口和类和 BeanDefinition 注册中心，别名注册中心，单例 Bean 注册中心相关；右下角的 ApplicationContext 与 Spring 应用上下文有关。")])])]),t._v(" "),n("h2",{attrs:{id:"applicationcontext-解析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#applicationcontext-解析"}},[t._v("#")]),t._v(" ApplicationContext 解析")]),t._v(" "),n("p",[t._v("ApplicationContext 就是 Spring 应用上下文，它不仅继承了 BeanFactory 体系，还提供更加高级的功能，更加适用于我们的正式应用环境。如以下几个功能：")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("继承 MessageSource，提供国际化的标准访问策略")])]),t._v(" "),n("li",[n("p",[t._v("继承 ApplicationEventPublisher ，提供强大的事件机制")])]),t._v(" "),n("li",[n("p",[t._v("扩展 ResourceLoader，可以用来加载多个 Resource，可以灵活访问不同的资源")])]),t._v(" "),n("li",[n("p",[t._v("对 Web 应用的支持")])])]),t._v(" "),n("h3",{attrs:{id:"applicationcontext-体系结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#applicationcontext-体系结构"}},[t._v("#")]),t._v(" ApplicationContext 体系结构")]),t._v(" "),n("p",[t._v("先来看看 ApplicationContext 接口的继承关系")]),t._v(" "),n("p",[n("img",{attrs:{src:"http://img.stormbuf.top/20210720174450.png",alt:""}})]),t._v(" "),n("p",[t._v("可以看到 ApplicationContext 除了继承 BeanFactory 接口以外，还继承了 MessageSource、ApplicationEventPublisher、ResourceLoader 等接口")]),t._v(" "),n("p",[t._v("简单描述几个接口：")]),t._v(" "),n("ul",[n("li",[n("p",[n("code",[t._v("org.springframework.core.io.ResourceLoader")]),t._v("，资源加载接口，用于访问不同的资源")])]),t._v(" "),n("li",[n("p",[n("code",[t._v("org.springframework.context.ApplicationEventPublisher")]),t._v("，事件发布器接口，支持发布事件")])]),t._v(" "),n("li",[n("p",[n("code",[t._v("org.springframework.context.MessageSource")]),t._v("，消息资源接口，提供国际化的标准访问策略")])]),t._v(" "),n("li",[n("p",[n("code",[t._v("org.springframework.core.env.EnvironmentCapable")]),t._v("，环境暴露接口，Spring 应用上下文支持多环境的配置")])]),t._v(" "),n("li",[n("p",[n("code",[t._v("org.springframework.context.ApplicationContext")]),t._v("，Spring 应用上下文，仅可读")])]),t._v(" "),n("li",[n("p",[n("code",[t._v("org.springframework.context.ConfigurableApplicationContext")]),t._v("，Spring 应用上下文，支持配置相关属性")])])]),t._v(" "),n("p",[t._v("接下来我们来看看它们的实现类的继承关系（部分）")]),t._v(" "),n("p",[n("img",{attrs:{src:"http://img.stormbuf.top/20210720174620.png",alt:""}})]),t._v(" "),n("p",[t._v("简单描述上面几个关键的类：")]),t._v(" "),n("ul",[n("li",[n("p",[n("code",[t._v("org.springframework.context.support.AbstractApplicationContext")]),t._v("，Spring 应用上下文的抽象类，实现了大部分功能，提供骨架方法交由子类去实现")])]),t._v(" "),n("li",[n("p",[n("code",[t._v("org.springframework.web.context.ConfigurableWebApplicationContext")]),t._v("，可配置的 Spring 应用上下文接口，支持 Web 应用")])]),t._v(" "),n("li",[n("p",[n("code",[t._v("org.springframework.context.support.AbstractRefreshableConfigApplicationContext")]),t._v("，支持设置 XML 文件")])]),t._v(" "),n("li",[n("p",[n("code",[t._v("org.springframework.web.context.support.AbstractRefreshableWebApplicationContext")]),t._v("，支持 Web 应用")])]),t._v(" "),n("li",[n("p",[n("code",[t._v("org.springframework.web.context.support.AnnotationConfigWebApplicationContext")]),t._v("，支持 Web 应用，可以设置 XML 文件，并可以扫描注解下面的 Bean")])]),t._v(" "),n("li",[n("p",[n("code",[t._v("org.springframework.context.annotation.AnnotationConfigApplicationContext")]),t._v("，支持扫描注解下面的 Bean")])]),t._v(" "),n("li",[n("p",[n("code",[t._v("org.springframework.web.context.support.ClassPathXmlApplicationContext")]),t._v("，支持设置 XML 文件，也可以从 classpath 下面扫描相关资源")])])]),t._v(" "),n("p",[t._v("ApplicationContext 的子类比较多，主要根据支持 Web、支持注解、支持 XML 文件三个功能进行区分，我们大致了解每个实现类的作用即可。其中基本的实现都是在 "),n("strong",[t._v("AbstractApplicationContext")]),t._v(" 这个抽象类中完成的，在它的 "),n("code",[t._v("refresh()")]),t._v(" 方法体现了 Spring 应用上下文的生命周期。"),n("code",[t._v("AbstractApplicationContext#refresh()")]),t._v(" 这个方法可以说是 Spring 应用上下文的准备阶段，在使用 Spring 时该方法会被调用。")]),t._v(" "),n("h2",{attrs:{id:"【核心】refresh-方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#【核心】refresh-方法"}},[t._v("#")]),t._v(" 【核心】refresh 方法")]),t._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Override")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("refresh")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throws")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BeansException")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("IllegalStateException")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// <1> 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("startupShutdownMonitor"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      \n      "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// <2> 刷新上下文环境的准备工作，记录下容器的启动时间、标记'已启动'状态、对上下文环境属性进行校验")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("prepareRefresh")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n      "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// <3> 创建并初始化一个 BeanFactory 对象 `beanFactory`，会加载出对应的 BeanDefinition 元信息们")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ConfigurableListableBeanFactory")]),t._v(" beanFactory "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("obtainFreshBeanFactory")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n      "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// <4> 为 `beanFactory` 进行一些准备工作，例如添加几个 BeanPostProcessor，手动注册几个特殊的 Bean")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("prepareBeanFactory")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("beanFactory"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n      "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// <5> 对 `beanFactory` 在进行一些后期的加工，交由子类进行扩展")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("postProcessBeanFactory")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("beanFactory"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// <6> 执行 BeanFactoryPostProcessor 处理器，包含 BeanDefinitionRegistryPostProcessor 处理器")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("invokeBeanFactoryPostProcessors")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("beanFactory"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// <7> 对 BeanPostProcessor 处理器进行初始化，并添加至 BeanFactory 中")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("registerBeanPostProcessors")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("beanFactory"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// <8> 设置上下文的 MessageSource 对象")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("initMessageSource")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// <9> 设置上下文的 ApplicationEventMulticaster 对象，上下文事件广播器")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("initApplicationEventMulticaster")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// <10> 刷新上下文时再进行一些初始化工作，交由子类进行扩展")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("onRefresh")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// <11> 将所有 ApplicationListener 监听器添加至 `applicationEventMulticaster` 事件广播器，如果已有事件则进行广播")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("registerListeners")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// <12> 设置 ConversionService 类型转换器，**初始化**所有还未初始化的 Bean（不是抽象、单例模式、不是懒加载方式）")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("finishBeanFactoryInitialization")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("beanFactory"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// <13> 刷新上下文的最后一步工作，会发布 ContextRefreshedEvent 上下文完成刷新事件")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("finishRefresh")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// <14> 如果上面过程出现 BeansException 异常")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("catch")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BeansException")]),t._v(" ex"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("logger"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("isWarnEnabled")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n          logger"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("warn")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Exception encountered during context initialization - "')]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("\n              "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"cancelling refresh attempt: "')]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" ex"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// <14.1> “销毁” 已注册的单例 Bean")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("destroyBeans")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// <14.2> 设置上下文的 `active` 状态为 `false`")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("cancelRefresh")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ex"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// <14.3> 抛出异常")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throw")]),t._v(" ex"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// <15> `finally` 代码块")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("finally")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Reset common introspection caches in Spring's core, since we")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// might not ever need metadata for singleton beans anymore...")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 清除相关缓存，例如通过反射机制缓存的 Method 和 Field 对象，缓存的注解元数据，缓存的泛型类型对象，缓存的类加载器")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("resetCommonCaches")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[n("strong",[n("code",[t._v("finishBeanFactoryInitialization(beanFactory)")])]),t._v("** 方法初始化了所有的非懒加载的单例bean。**")]),t._v(" "),n("h2",{attrs:{id:"beandefinition-解析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#beandefinition-解析"}},[t._v("#")]),t._v(" BeanDefinition 解析")]),t._v(" "),n("p",[t._v("BeanDefinition 介绍")]),t._v(" "),n("h3",{attrs:{id:"面向注解的解析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#面向注解的解析"}},[t._v("#")]),t._v(" 面向注解的解析")]),t._v(" "),n("p",[t._v("核心类是 "),n("code",[t._v("org.springframework.context.annotation.ClassPathBeanDefinitionScanner")]),t._v("。")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("该类在创建时设置了基于"),n("code",[t._v("@Component")]),t._v(" 注解的过滤器。")])]),t._v(" "),n("li",[n("p",[t._v("调用"),n("code",[t._v("doScan(String... basePackages)")]),t._v(" 方法，根据过滤器扫描出包路径（入参的就是包路径）下符合条件 .class文件，生成 "),n("code",[t._v("BeanDefinition")]),t._v("。")])]),t._v(" "),n("li",[n("p",[t._v("将 "),n("code",[t._v("BeanDefinition")]),t._v("封装成 "),n("code",[t._v("BeanDefinitionHolder")]),t._v("对象（这里多了一个 "),n("code",[t._v("beanName")]),t._v("），并注册到"),n("code",[t._v("BeanDefinitionRegistry")]),t._v("中")])]),t._v(" "),n("li",[n("p",[t._v("如果代理模式是 "),n("strong",[t._v("TARGET_CLASS")]),t._v("，则再创建一个 "),n("code",[t._v("BeanDefinition")]),t._v("代理对象（重新设置了相关属性），原始 "),n("code",[t._v("BeanDefinition")]),t._v("已注册（该处与"),n("strong",[t._v("AOP")]),t._v("相关）")])])]),t._v(" "),n("h2",{attrs:{id:"spring-扩展点解析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring-扩展点解析"}},[t._v("#")]),t._v(" Spring 扩展点解析")]),t._v(" "),n("h2",{attrs:{id:"广播机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#广播机制"}},[t._v("#")]),t._v(" 广播机制")]),t._v(" "),n("h1",{attrs:{id:"bean-的创建和生命周期"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bean-的创建和生命周期"}},[t._v("#")]),t._v(" bean 的创建和生命周期")]),t._v(" "),n("p",[t._v("创建 Bean 的过程如下：")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("Class 对象加载阶段")])]),t._v(" "),n("li",[n("p",[t._v("实例化前阶段（如果返回了一个对象则直接返回，不会进行下面的阶段）")])]),t._v(" "),n("li",[n("p",[t._v("实例化阶段")])]),t._v(" "),n("li",[n("p",[t._v("实例化后阶段")])]),t._v(" "),n("li",[n("p",[t._v("提前暴露单例 Bean（循环依赖处理的关键）")])]),t._v(" "),n("li",[n("p",[t._v("属性填充阶段")])]),t._v(" "),n("li",[n("p",[t._v("Aware 接口回调阶段")])]),t._v(" "),n("li",[n("p",[t._v("初始化前阶段")])]),t._v(" "),n("li",[n("p",[t._v("初始化阶段")])]),t._v(" "),n("li",[n("p",[t._v("初始化后阶段")])])]),t._v(" "),n("p",[n("img",{attrs:{src:"http://img.stormbuf.top/java0-1559531915.jpg",alt:""}})]),t._v(" "),n("h2",{attrs:{id:"dogetbean-方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#dogetbean-方法"}},[t._v("#")]),t._v(" doGetBean 方法")]),t._v(" "),n("p",[n("code",[t._v("doGetBean(final String name, @Nullable final Class<T> requiredType, @Nullable final Object[] args, boolean typeCheckOnly)")])]),t._v(" "),n("p",[t._v("该方法是获取与创建bean的核心方法。")]),t._v(" "),n("h2",{attrs:{id:"createbean"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#createbean"}},[t._v("#")]),t._v(" createBean")]),t._v(" "),n("p",[n("code",[t._v("AbstractAutowireCapableBeanFactory#createBean(String, RootBeanDefinition, Object[])")])]),t._v(" "),n("p",[t._v("该方法是创建bean的核心方法。由"),n("code",[t._v("doGetBean")]),t._v("调用。")]),t._v(" "),n("p",[n("code",[t._v("createBean")]),t._v("通过调用"),n("code",[t._v("doCreateBean")]),t._v("方法创建bean。")]),t._v(" "),n("p",[t._v("过程大致如下：")]),t._v(" "),n("ol",[n("li",[t._v("获取 "),n("code",[t._v("mbd")]),t._v(" 对应的 Class 对象，确保当前 Bean 能够被创建出来，调用 "),n("code",[t._v("resolveBeanClass(...)")]),t._v(" 方法")]),t._v(" "),n("li",[t._v("对所有的 MethodOverride 进行"),n("strong",[t._v("验证")]),t._v("和"),n("strong",[t._v("准备")]),t._v("工作（确保存在对应的方法，并设置为不能重复加载）")]),t._v(" "),n("li",[n("strong",[t._v("实例化前阶段")]),t._v("在实例化前进行相关处理，会先调用所有 InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation\n注意，如果这里返回对象不是 "),n("code",[t._v("null")]),t._v(" 的话，不会继续往下执行原本初始化操作，"),n("strong",[t._v("直接返回")]),t._v("，也就是说这个方法返回的是最终实例对象\n可以通过这种方式"),n("strong",[t._v("提前返回")]),t._v("一个代理对象，例如 AOP 的实现，或者 RPC 远程调用的实现（因为本地类没有远程能力，可以通过这种方式进行拦截）")]),t._v(" "),n("li",[t._v("创建 Bean 对象 "),n("code",[t._v("beanInstance")]),t._v("，如果上一步没有返回代理对象，就只能走常规的路线进行 Bean 的创建了，调用 "),n("code",[t._v("doCreateBean(...)")]),t._v(" 方法")]),t._v(" "),n("li",[t._v("将 "),n("code",[t._v("beanInstance")]),t._v(" 返回\n可以看到这个方法中并没有开始真正 Bean 的创建，在这个方法的第 "),n("code",[t._v("4")]),t._v(" 步会调用 "),n("code",[t._v("doCreateBean(...)")]),t._v(" 方法创建 Bean")])]),t._v(" "),n("h2",{attrs:{id:"docreatebean"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#docreatebean"}},[t._v("#")]),t._v(" doCreateBean")]),t._v(" "),n("p",[t._v("过程大致如下：")]),t._v(" "),n("ol",[n("li",[t._v("Bean 的"),n("strong",[t._v("实例化阶段")]),t._v("，会将 Bean 的实例对象封装成 BeanWrapperImpl 包装对象")]),t._v(" "),n("li",[t._v("如果是单例模式，则先尝试从 "),n("code",[t._v("factoryBeanInstanceCache")]),t._v(" 缓存中获取实例对象，并从缓存中移除")]),t._v(" "),n("li",[t._v("使用合适的实例化策略来创建 Bean 的实例：工厂方法、构造函数自动注入、简单初始化，主要是将 BeanDefinition 转换为 BeanWrapper 对象\n调用 "),n("code",[t._v("createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)")]),t._v(" 方法")]),t._v(" "),n("li",[t._v("获取包装的实例对象 "),n("code",[t._v("bean")]),t._v("4.  获取包装的实例对象的类型 "),n("code",[t._v("beanType")]),t._v("2.  对 "),n("code",[t._v("RootBeanDefinition")]),t._v("（合并后）进行"),n("strong",[t._v("加工处理")]),t._v("1.  如果该 "),n("code",[t._v("RootBeanDefinition")]),t._v("没有处理过，则进行下面的处理")]),t._v(" "),n("li",[t._v("调用所有的 "),n("code",[t._v("MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition")]),t._v("，这个过程非常重要，例如 Spring 内有下面两个处理器：")])]),t._v(" "),n("ul",[n("li",[n("p",[n("code",[t._v("AutowiredAnnotationBeanPostProcessor")]),t._v("，会先解析出 "),n("code",[t._v("@Autowired")]),t._v(" 和 "),n("code",[t._v("@Value")]),t._v(" 注解标注的属性的注入元信息，后续进行依赖注入")])]),t._v(" "),n("li",[n("p",[n("code",[t._v("CommonAnnotationBeanPostProcessor")]),t._v("，会先解析出 "),n("code",[t._v("@Resource")]),t._v(" 注解标注的属性的注入元信息，后续进行依赖注入，它也会找到 "),n("code",[t._v("@PostConstruct")]),t._v(" 和 "),n("code",[t._v("@PreDestroy")]),t._v(" 注解标注的方法，并构建一个 "),n("code",[t._v("LifecycleMetadata")]),t._v("对象，用于后续生命周期中的初始化和销毁")])])]),t._v(" "),n("ol",{attrs:{start:"3"}},[n("li",[t._v("设置该 "),n("code",[t._v("RootBeanDefinition")]),t._v("被处理过，避免重复处理")]),t._v(" "),n("li",[n("strong",[t._v("提前暴露")]),t._v("这个 "),n("code",[t._v("bean")]),t._v("，如果可以的话，目的是解决单例模式 Bean 的循环依赖注入")]),t._v(" "),n("li",[t._v("判断是否可以提前暴露，满足三个条件：单例模式、允许循环依赖（默认为 true）、当前单例 bean 正在被创建，在前面已经标记过")]),t._v(" "),n("li",[t._v("创建一个 "),n("code",[t._v("ObjectFactory")]),t._v("实现类，用于返回当前正在被创建的 "),n("code",[t._v("bean")]),t._v("，提前暴露，保存在 "),n("code",[t._v("singletonFactories")]),t._v(" （"),n("strong",[t._v("三级 Map")]),t._v("）缓存中")])]),t._v(" "),n("hr"),t._v(" "),n("p",[t._v("接下来开始初始化上面的 "),n("code",[t._v("bean")]),t._v(" 实例对象，会先创建一个 "),n("code",[t._v("Object exposedObject")]),t._v(" 等于 "),n("code",[t._v("bean")]),t._v(" （引用）\n4.  对 "),n("code",[t._v("bean")]),t._v(" 进行"),n("strong",[t._v("属性填充")]),t._v("，注入对应的属性值，调用 "),n("code",[t._v("populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)")]),t._v(" 方法\n5.  "),n("strong",[t._v("初始化")]),t._v("这个 "),n("code",[t._v("exposedObject")]),t._v("，调用其初始化方法，调用 "),n("code",[t._v("initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd)")]),t._v(" 方法")]),t._v(" "),n("hr"),t._v(" "),n("ol",{attrs:{start:"6"}},[n("li",[n("strong",[t._v("循环依赖注入的检查")]),t._v("1.  获取当前正在创建的 "),n("code",[t._v("beanName")]),t._v(" 被依赖注入的早期引用，调用 "),n("code",[t._v("DefaultSingletonBeanRegistry#getSingleton(String beanName, boolean allowEarlyReference)")]),t._v(" 方法。注意，这里有一个入参是 "),n("code",[t._v("false")]),t._v("，不会调用上面第 "),n("code",[t._v("3")]),t._v(" 步的 "),n("code",[t._v("ObjectFactory")]),t._v("实现类，也就是说当前 "),n("code",[t._v("bean")]),t._v(" 如果出现循环依赖注入，这里才能获取到提前暴露的引用")]),t._v(" "),n("li",[t._v("如果出现了循环依赖注入，则进行接下来的检查工作")]),t._v(" "),n("li",[t._v("如果 "),n("code",[t._v("exposedObject")]),t._v(" 没有在初始化阶段中被改变，也就是没有被增强，则使用提前暴露的那个引用")]),t._v(" "),n("li",[t._v("否则，"),n("code",[t._v("exposedObject")]),t._v(" 已经不是被别的 Bean 依赖注入的那个 Bean，如果依赖当前 "),n("code",[t._v("beanName")]),t._v(" 的 Bean（通过 "),n("code",[t._v("depends-on")]),t._v(" 配置）已经被创建，则抛出异常")]),t._v(" "),n("li",[t._v("为当前 "),n("code",[t._v("bean")]),t._v(" 注册 "),n("code",[t._v("DisposableBeanAdapter")]),t._v("（如果需要的话），用于 Bean 生命周期中的销毁阶段")]),t._v(" "),n("li",[t._v("返回创建好的 "),n("code",[t._v("exposedObject")]),t._v(" 对象\n概括：")])]),t._v(" "),n("ul",[n("li",[n("p",[t._v("首先获取对应的 Class 对象，创建一个实例对象")])]),t._v(" "),n("li",[n("p",[t._v("对这个实例对象进行属性填充")])]),t._v(" "),n("li",[n("p",[t._v("调用这个实例对象的初始化方法")])])]),t._v(" "),n("hr"),t._v(" "),n("h2",{attrs:{id:"createbeaninstance"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#createbeaninstance"}},[t._v("#")]),t._v(" createBeanInstance")]),t._v(" "),n("p",[t._v("在 "),n("code",[t._v("doCreateBean")]),t._v(" 被调用，创建一个 Bean 的实例对象，并将 Bean 的实例对象封装成 "),n("code",[t._v("BeanWrapperImpl")]),t._v("包装对象返回。")]),t._v(" "),n("p",[t._v("过程大致如下：")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("获取 "),n("code",[t._v("beanName")]),t._v(" 对应的 Class 对象")])]),t._v(" "),n("li",[n("p",[t._v("如果存在 Supplier 实例化回调接口，则使用给定的回调方法创建一个实例对象")])]),t._v(" "),n("li",[n("p",[t._v("如果配置了 "),n("code",[t._v("factory-method")]),t._v(" 工厂方法，则调用该方法来创建一个实例对象，通过 @Bean 标注的方法会通过这里进行创建")])])]),t._v(" "),n("hr"),t._v(" "),n("p",[t._v("如果上面两种情况都不是，那么就进行接下来正常创建 Bean 实例的一个过程")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("判断这个 RootBeanDefinition 的构造方法是否已经被解析出来了，因为找到最匹配的构造方法比较繁琐，找到后会设置到 RootBeanDefinition 中，避免重复这个过程")])]),t._v(" "),n("li",[n("p",[t._v("RootBeanDefinition 的 "),n("code",[t._v("resolvedConstructorOrFactoryMethod")]),t._v(" 是否不为空，不为空表示构造方法已经解析出来了")])]),t._v(" "),n("li",[n("p",[t._v("构造方法已经解析出来了，则判断它的 "),n("code",[t._v("constructorArgumentsResolved")]),t._v(" 是否不为空，不为空表示有入参，需要先获取到对应的入参（构造器注入）")])]),t._v(" "),n("li",[n("p",[t._v("如果最匹配的构造方法已解析出来")])]),t._v(" "),n("li",[n("p",[t._v("如果这个构造方法有入参，则找到最匹配的构造方法，这里会拿到已经被解析出来的这个方法，并找到入参（构造器注入），然后调用该方法返回一个实例对象（反射机制）")])]),t._v(" "),n("li",[n("p",[t._v("否则，没有入参，直接调用解析出来构造方法，返回一个实例对象（反射机制）")])]),t._v(" "),n("li",[n("p",[t._v("如果最匹配的构造方法还没开始解析，那么需要找到一个最匹配的构造方法，然后创建一个实例对象")])]),t._v(" "),n("li",[n("p",[t._v("先尝试通过 SmartInstantiationAwareBeanPostProcessor 处理器找到一些合适的构造方法，保存在 "),n("code",[t._v("ctors")]),t._v(" 中")])]),t._v(" "),n("li",[n("p",[t._v("是否满足下面其中一个条件："),n("code",[t._v("ctors")]),t._v(" 不为空、构造器注入模式、定义了构造方法的入参、当前方法指定了入参，")])])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("则找到最匹配的构造方法，如果 `ctors` 不为空，会从这里面找一个最匹配的，并找到入参（构造器注入），然后调用该方法返回一个实例对象（反射机制）\n")])])]),n("ol",[n("li",[n("p",[t._v("如果第 "),n("code",[t._v("6")]),t._v(" 步还不满足，那么尝试从 RootBeanDefinition 中获取优先的构造方法")])]),t._v(" "),n("li",[n("p",[t._v("如果存在优先的构造方法，则从里面找到最匹配的一个，并找到入参（构造器注入），然后调用该方法返回一个实例对象（反射机制）")])]),t._v(" "),n("li",[n("p",[t._v("如果上面多种情况都不满足，那只能使用兜底方法了，直接调用默认构造方法返回一个实例对象（反射机制）")])])]),t._v(" "),n("hr"),t._v(" "),n("p",[t._v("整个的实例化过程非常的复杂，接下来进行概括：")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("先拿到对应 Class 对象")])]),t._v(" "),n("li",[n("p",[t._v("如果设置了 Supplier 实例化回调接口，则通过该回调接口获取实例对象")])]),t._v(" "),n("li",[n("p",[t._v("如果配置了通过 "),n("code",[t._v("factory-method")]),t._v(" 工厂方法获取实例对象，则通过这个方法创建实例对象，@Bean 标注的方法也是通过这里创建实例对象，方法入参会依赖注入")])]),t._v(" "),n("li",[n("p",[t._v("找到最匹配的一个构造方法，并找到对应的入参（构造器注入），通过调用该方法返回一个实例对象")])]),t._v(" "),n("li",[n("p",[t._v("兜底方法，调用默认构造方法创建一个实例对象")])])]),t._v(" "),n("p",[t._v("BeanWrapperImpl 承担的角色：")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("Bean 实例的包装")])]),t._v(" "),n("li",[n("p",[n("code",[t._v("org.springframework.beans.PropertyAccessor")]),t._v("  属性编辑器")])]),t._v(" "),n("li",[n("p",[n("code",[t._v("org.springframework.beans.PropertyEditorRegistry")]),t._v("  属性编辑器注册表")])]),t._v(" "),n("li",[n("p",[t._v("类型转换器")])])]),t._v(" "),n("h2",{attrs:{id:"populatebean"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#populatebean"}},[t._v("#")]),t._v(" populateBean")]),t._v(" "),n("p",[t._v("用作"),n("strong",[t._v("属性填充")]),t._v("。")]),t._v(" "),n("h2",{attrs:{id:"三级缓存"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三级缓存"}},[t._v("#")]),t._v(" 三级缓存")]),t._v(" "),n("p",[t._v("作用：解决属性注入和Setter注入的循环依赖，无法解决构造器注入的循环依赖。")]),t._v(" "),n("p",[t._v("说明：这里的循环依赖指的是"),n("strong",[t._v("单例模式")]),t._v("下的 Bean "),n("strong",[t._v("字段注入")]),t._v("时出现的循环依赖。"),n("strong",[t._v("构造器注入")]),t._v("对于 Spring 无法自动解决（应该考虑代码设计是否有问题），可通过延迟初始化来处理。Spring 只解决"),n("strong",[t._v("单例模式")]),t._v("下的循环依赖。")]),t._v(" "),n("p",[t._v("在 Spring 底层 IoC 容器 BeanFactory 中处理循环依赖的方法主要借助于以下 "),n("code",[t._v("3")]),t._v(" 个 Map 集合：")]),t._v(" "),n("ol",[n("li",[n("p",[n("code",[t._v("singletonObjects")]),t._v("（一级 Map），里面保存了所有已经初始化好的单例 Bean，也就是会保存 Spring IoC 容器中所有单例的 Spring Bean；")])]),t._v(" "),n("li",[n("p",[n("code",[t._v("earlySingletonObjects")]),t._v("（二级 Map），里面会保存从 "),n("strong",[t._v("三级 Map")]),t._v(" 获取到的正在初始化的 Bean")])]),t._v(" "),n("li",[n("p",[n("code",[t._v("singletonFactories")]),t._v("（三级 Map），里面保存了正在初始化的 Bean 对应的 ObjectFactory 实现类，调用其 getObject() 方法返回正在初始化的 Bean 对象（仅实例化还没完全初始化好），如果存在则将获取到的 Bean 对象并保存至 "),n("strong",[t._v("二级 Map")]),t._v("，同时从当前 "),n("strong",[t._v("三级 Map")]),t._v(" 移除该 ObjectFactory 实现类。")])])]),t._v(" "),n("p",[t._v("当通过 getBean 依赖查找时会首先依次从上面三个 Map 获取，存在则返回，不存在则进行初始化，这三个 Map 是处理循环依赖的关键。")]),t._v(" "),n("p",[t._v("例如两个 Bean 出现循环依赖，A 依赖 B，B 依赖 A；当我们去依赖查找 A，在实例化后初始化前会先生成一个 ObjectFactory 对象（可获取当前正在初始化 A）保存在上面的 "),n("code",[t._v("singletonFactories")]),t._v(" 中，初始化的过程需注入 B；接下来去查找 B，初始 B 的时候又要去注入 A，又去查找 A ，由于可以通过 "),n("code",[t._v("singletonFactories")]),t._v(" 直接拿到正在初始化的 A，那么就可以完成 B 的初始化，最后也完成 A 的初始化，这样就避免出现循环依赖。")]),t._v(" "),n("blockquote",[n("p",[t._v("B（也依赖 A） -> C -> A，当你获取 A 这个 Bean 时，后续 B 和 C 都要注入 A，没有上面的 "),n("strong",[t._v("二级 Map")]),t._v("的话，"),n("strong",[t._v("三级 Map")]),t._v(" 保存的 ObjectFactory 实现类会被调用两次，会重复处理，可能出现问题，这样做在性能上也有所提升\n"),n("strong",[t._v("问题二")]),t._v("：为什么不直接调用这个 ObjectFactory#getObject() 方法放入 "),n("strong",[t._v("二级Map")]),t._v(" 中，而需要上面的 "),n("strong",[t._v("三级 Map")]),t._v("？\n对于不涉及到 AOP 的 Bean 确实可以不需要 "),n("code",[t._v("singletonFactories")]),t._v("（三级 Map），但是 Spring AOP 就是 Spring 体系中的一员，如果没有"),n("code",[t._v("singletonFactories")]),t._v("（三级 Map），意味着 Bean 在实例化后就要完成 AOP 代理，这样违背了 Spring 的设计原则。Spring 是通过 "),n("code",[t._v("AnnotationAwareAspectJAutoProxyCreator")]),t._v(" 这个后置处理器在完全创建好 Bean 后来完成 AOP 代理，而不是在实例化后就立马进行 AOP 代理。如果出现了循环依赖，那没有办法，只有给 Bean 先创建代理对象，但是在没有出现循环依赖的情况下，设计之初就是让 Bean 在完全创建好后才完成 AOP 代理。")])]),t._v(" "),n("blockquote",[n("p",[t._v("提示："),n("code",[t._v("AnnotationAwareAspectJAutoProxyCreator")]),t._v(" 是一个 "),n("code",[t._v("SmartInstantiationAwareBeanPostProcessor")]),t._v(" 后置处理器，在它的 getEarlyBeanReference(..) 方法中可以创建代理对象。所以说对于上面的"),n("strong",[t._v("问题二")]),t._v("，如果出现了循环依赖，如果是一个 AOP 代理对象，那只能给 Bean 先创建代理对象，设计之初就是让 Bean 在完全创建好后才完成 AOP 代理。")])]),t._v(" "),n("blockquote",[n("p",[t._v("为什么 Spring 的设计是让 Bean 在完全创建好后才完成 AOP 代理？")])]),t._v(" "),n("p",[t._v("因为创建的代理对象需要关联目标对象，在拦截处理的过程中需要根据目标对象执行被拦截的方法，所以这个目标对象最好是一个“成熟态”，而不是仅实例化还未初始化的一个对象。")]),t._v(" "),n("h1",{attrs:{id:"aop"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#aop"}},[t._v("#")]),t._v(" aop")]),t._v(" "),n("p",[t._v("Bean 的加载过程，整个过程中会调用相应的 BeanPostProcessor 对正在创建 Bean 进行处理，例如：")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("在 Bean 的实例化前，会调用 "),n("code",[t._v("InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation(..)")]),t._v(" 方法进行处理")])]),t._v(" "),n("li",[n("p",[t._v("在 Bean 出现循环依赖的情况下，会调用 "),n("code",[t._v("SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference(..)")]),t._v(" 方法对提前暴露的 Bean 进行处理")])]),t._v(" "),n("li",[n("p",[t._v("在 Bean 初始化后，会调用 "),n("code",[t._v("BeanPostProcessor#postProcessAfterInitialization(..)")]),t._v(" 方法对初始化好的 Bean 进行处理")])])]),t._v(" "),n("p",[t._v("Spring AOP 则是通过上面三个切入点进行创建代理对象，实现"),n("strong",[t._v("自动代理")]),t._v("。")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("在 Spring AOP 中主要是通过第 "),n("code",[t._v("3")]),t._v(" 种 BeanPostProcessor 创建代理对象，在 Bean 初始化后，也就是一个“成熟态”，然后再尝试是否创建一个代理对象；")])]),t._v(" "),n("li",[n("p",[t._v("第 "),n("code",[t._v("2")]),t._v(" 种方式是为了解决 Bean 循环依赖的问题，虽然 Bean 仅实例化还未初始化，但是出现了循环依赖，不得不在此时创建一个代理对象；")])]),t._v(" "),n("li",[n("p",[t._v("第 "),n("code",[t._v("1")]),t._v(" 种方式是在 Bean 还没有实例化的时候就提前创建一个代理对象（创建了则不会继续后续的 Bean 的创建过程），例如 RPC 远程调用的实现，因为本地类没有远程能力，可以通过这种方式进行拦截。")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);