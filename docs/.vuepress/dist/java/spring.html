<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>spring | stormbuf&#39;s blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/img/logo.png">
    <link rel="manifest" href="/manifest.json">
    <script src="https://www.googletagmanager.com/gtag/js?id=UA-286583-7" async="true"></script>
    <script> window.dataLayer = window.dataLayer || [];                function gtag(){dataLayer.push(arguments);}                gtag('js', new Date());                gtag('config', 'UA-286583-7');</script>
    <link rel="alternate" type="application/rss+xml" href="https://stormbuf.top/rss.xml" title="stormbuf&#39;s blog RSS Feed">
    <meta name="description" content="stormbuf 的博客">
    
    <link rel="preload" href="/assets/css/0.styles.1ac74570.css" as="style"><link rel="preload" href="/assets/js/app.586101e3.js" as="script"><link rel="preload" href="/assets/js/2.f36e1316.js" as="script"><link rel="preload" href="/assets/js/16.6195d00e.js" as="script"><link rel="preload" href="/assets/js/4.efbf2f21.js" as="script"><link rel="prefetch" href="/assets/js/10.b52431e5.js"><link rel="prefetch" href="/assets/js/11.270e6b2b.js"><link rel="prefetch" href="/assets/js/12.b1b481c0.js"><link rel="prefetch" href="/assets/js/13.478c3a4c.js"><link rel="prefetch" href="/assets/js/14.d198872d.js"><link rel="prefetch" href="/assets/js/15.26731815.js"><link rel="prefetch" href="/assets/js/17.4e5e0b7f.js"><link rel="prefetch" href="/assets/js/18.88b6cd8b.js"><link rel="prefetch" href="/assets/js/19.dddb20bb.js"><link rel="prefetch" href="/assets/js/3.738acb67.js"><link rel="prefetch" href="/assets/js/5.08c1d800.js"><link rel="prefetch" href="/assets/js/6.928faf93.js"><link rel="prefetch" href="/assets/js/7.99ec363d.js"><link rel="prefetch" href="/assets/js/8.6c1407ab.js"><link rel="prefetch" href="/assets/js/9.702cc898.js">
    <link rel="stylesheet" href="/assets/css/0.styles.1ac74570.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">stormbuf's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/java/" class="nav-link router-link-active">
  java
</a></div><div class="nav-item"><a href="/db/" class="nav-link">
  数据库
</a></div><div class="nav-item"><a href="/archivesPage/" class="nav-link">
  归档
</a></div><div class="nav-item"><a href="/friends/" class="nav-link">
  友链
</a></div><div class="nav-item"><a href="https://stormbuf.top/rss.xml" target="_self" class="nav-link external">
  RSS
  <!----></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/java/" class="nav-link router-link-active">
  java
</a></div><div class="nav-item"><a href="/db/" class="nav-link">
  数据库
</a></div><div class="nav-item"><a href="/archivesPage/" class="nav-link">
  归档
</a></div><div class="nav-item"><a href="/friends/" class="nav-link">
  友链
</a></div><div class="nav-item"><a href="https://stormbuf.top/rss.xml" target="_self" class="nav-link external">
  RSS
  <!----></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>spring</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/java/spring.html#beanfactorypostprocessor-接口" class="sidebar-link">BeanFactoryPostProcessor 接口</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/spring.html#beanfactory解析" class="sidebar-link">BeanFactory解析</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/spring.html#applicationcontext-解析" class="sidebar-link">ApplicationContext 解析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/spring.html#applicationcontext-体系结构" class="sidebar-link">ApplicationContext 体系结构</a></li></ul></li><li><a href="/java/spring.html#【核心】refresh-方法" class="sidebar-link">【核心】refresh 方法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/spring.html#beandefinition-解析" class="sidebar-link">BeanDefinition 解析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/spring.html#面向注解的解析" class="sidebar-link">面向注解的解析</a></li></ul></li><li><a href="/java/spring.html#spring-扩展点解析" class="sidebar-link">Spring 扩展点解析</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/spring.html#广播机制" class="sidebar-link">广播机制</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/spring.html#dogetbean-方法" class="sidebar-link">doGetBean 方法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/spring.html#createbean" class="sidebar-link">createBean</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/spring.html#docreatebean" class="sidebar-link">doCreateBean</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/spring.html#createbeaninstance" class="sidebar-link">createBeanInstance</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/spring.html#populatebean" class="sidebar-link">populateBean</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/spring.html#三级缓存" class="sidebar-link">三级缓存</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="spring"><a href="#spring" class="header-anchor">#</a> spring</h1> <h1 id="beanfactory"><a href="#beanfactory" class="header-anchor">#</a> BeanFactory</h1> <h2 id="beanfactorypostprocessor-接口"><a href="#beanfactorypostprocessor-接口" class="header-anchor">#</a> BeanFactoryPostProcessor 接口</h2> <p><code>BeanFactoryPostProcessor</code>是一个函数式接口，里面只有一个方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BeanFactoryPostProcessor</span> <span class="token punctuation">{</span>

  <span class="token comment">/**
   * Modify the application context's internal bean factory after its standard
   * initialization. All bean definitions will have been loaded, but no beans
   * will have been instantiated yet. This allows for overriding or adding
   * properties even to eager-initializing beans.
   * @param beanFactory the bean factory used by the application context
   * @throws org.springframework.beans.BeansException in case of errors
   */</span>
  <span class="token keyword">void</span> <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableListableBeanFactory</span> beanFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><p>我们可以通过实现<code>BeanFactoryPostProcessor</code>接口，获取<code>BeanFactory</code>，操作<code>BeanFactory</code>对象，修改<code>BeanDefinition</code>，但不要去实例化bean。</p> <p><strong>todo</strong>：</p> <ol><li><p>springboot <code>ApplicationContext</code> 类继承结构，各接口和抽象模板类作用</p></li> <li><p><code>BeanDefinition</code> 如何被自动装配？</p></li> <li><p>ioc 容器初始化流程</p></li></ol> <h1 id="ioc容器的创建"><a href="#ioc容器的创建" class="header-anchor">#</a> IOC容器的创建</h1> <h2 id="beanfactory解析"><a href="#beanfactory解析" class="header-anchor">#</a> BeanFactory解析</h2> <p>BeanFactory 接口的继承关系：</p> <p><img src="http://img.stormbuf.top/20210720115542.png" alt=""></p> <p>简单描述这些接口：</p> <ul><li><p><code>org.springframework.beans.factory.BeanFactory</code>，Spring IoC 容器最基础的接口，提供依赖查找<strong>单个</strong> Bean 的功能</p></li> <li><p><code>org.springframework.beans.factory.ListableBeanFactory</code>，继承 BeanFactory 接口，提供依赖查找<strong>多个</strong> Bean 的功能</p></li> <li><p><code>org.springframework.beans.factory.HierarchicalBeanFactory</code>，继承 BeanFactory 接口，提供获取父 BeanFactory 的功能，具有<strong>层次性</strong></p></li> <li><p><code>org.springframework.beans.factory.config.ConfigurableBeanFactory</code>，继承 HierarchicalBeanFactory 接口，提供可操作内部相关组件的功能，具有<strong>可配置性</strong></p></li> <li><p><code>org.springframework.beans.factory.config.AutowireCapableBeanFactory</code>，继承 BeanFactory 接口，提供可注入的功能，支持<strong>依赖注入</strong></p></li> <li><p><code>org.springframework.beans.factory.config.ConfigurableListableBeanFactory</code>，继承上面所有接口，综合所有特性，还提供可提前初始化所有单例 Bean 的功能
通过这些接口的名称可以大致了解其用意，接下来我们来看看它们的实现类的继承关系</p></li></ul> <p><img src="http://img.stormbuf.top/DefaultListableBeanFactory.png" alt=""></p> <p>简单描述这些实现类：</p> <ul><li><p><code>org.springframework.beans.factory.support.AbstractBeanFactory</code> 抽象类，实现 ConfigurableBeanFactory 接口，基础实现类，Bean 的创建过程交由子类实现</p></li> <li><p><code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory</code> 抽象类，继承 AbstractBeanFactory，实现 AutowireCapableBeanFactory 接口，完成 Bean 的创建</p></li> <li><p><code>org.springframework.beans.factory.support.DefaultListableBeanFactory</code>，Spring 底层 IoC 容器，依赖注入的底层实现
其他的接口和类和 BeanDefinition 注册中心，别名注册中心，单例 Bean 注册中心相关；右下角的 ApplicationContext 与 Spring 应用上下文有关。</p></li></ul> <h2 id="applicationcontext-解析"><a href="#applicationcontext-解析" class="header-anchor">#</a> ApplicationContext 解析</h2> <p>ApplicationContext 就是 Spring 应用上下文，它不仅继承了 BeanFactory 体系，还提供更加高级的功能，更加适用于我们的正式应用环境。如以下几个功能：</p> <ul><li><p>继承 MessageSource，提供国际化的标准访问策略</p></li> <li><p>继承 ApplicationEventPublisher ，提供强大的事件机制</p></li> <li><p>扩展 ResourceLoader，可以用来加载多个 Resource，可以灵活访问不同的资源</p></li> <li><p>对 Web 应用的支持</p></li></ul> <h3 id="applicationcontext-体系结构"><a href="#applicationcontext-体系结构" class="header-anchor">#</a> ApplicationContext 体系结构</h3> <p>先来看看 ApplicationContext 接口的继承关系</p> <p><img src="http://img.stormbuf.top/20210720174450.png" alt=""></p> <p>可以看到 ApplicationContext 除了继承 BeanFactory 接口以外，还继承了 MessageSource、ApplicationEventPublisher、ResourceLoader 等接口</p> <p>简单描述几个接口：</p> <ul><li><p><code>org.springframework.core.io.ResourceLoader</code>，资源加载接口，用于访问不同的资源</p></li> <li><p><code>org.springframework.context.ApplicationEventPublisher</code>，事件发布器接口，支持发布事件</p></li> <li><p><code>org.springframework.context.MessageSource</code>，消息资源接口，提供国际化的标准访问策略</p></li> <li><p><code>org.springframework.core.env.EnvironmentCapable</code>，环境暴露接口，Spring 应用上下文支持多环境的配置</p></li> <li><p><code>org.springframework.context.ApplicationContext</code>，Spring 应用上下文，仅可读</p></li> <li><p><code>org.springframework.context.ConfigurableApplicationContext</code>，Spring 应用上下文，支持配置相关属性</p></li></ul> <p>接下来我们来看看它们的实现类的继承关系（部分）</p> <p><img src="http://img.stormbuf.top/20210720174620.png" alt=""></p> <p>简单描述上面几个关键的类：</p> <ul><li><p><code>org.springframework.context.support.AbstractApplicationContext</code>，Spring 应用上下文的抽象类，实现了大部分功能，提供骨架方法交由子类去实现</p></li> <li><p><code>org.springframework.web.context.ConfigurableWebApplicationContext</code>，可配置的 Spring 应用上下文接口，支持 Web 应用</p></li> <li><p><code>org.springframework.context.support.AbstractRefreshableConfigApplicationContext</code>，支持设置 XML 文件</p></li> <li><p><code>org.springframework.web.context.support.AbstractRefreshableWebApplicationContext</code>，支持 Web 应用</p></li> <li><p><code>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</code>，支持 Web 应用，可以设置 XML 文件，并可以扫描注解下面的 Bean</p></li> <li><p><code>org.springframework.context.annotation.AnnotationConfigApplicationContext</code>，支持扫描注解下面的 Bean</p></li> <li><p><code>org.springframework.web.context.support.ClassPathXmlApplicationContext</code>，支持设置 XML 文件，也可以从 classpath 下面扫描相关资源</p></li></ul> <p>ApplicationContext 的子类比较多，主要根据支持 Web、支持注解、支持 XML 文件三个功能进行区分，我们大致了解每个实现类的作用即可。其中基本的实现都是在 <strong>AbstractApplicationContext</strong> 这个抽象类中完成的，在它的 <code>refresh()</code> 方法体现了 Spring 应用上下文的生命周期。<code>AbstractApplicationContext#refresh()</code> 这个方法可以说是 Spring 应用上下文的准备阶段，在使用 Spring 时该方法会被调用。</p> <h2 id="【核心】refresh-方法"><a href="#【核心】refresh-方法" class="header-anchor">#</a> 【核心】refresh 方法</h2> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">,</span> <span class="token class-name">IllegalStateException</span> <span class="token punctuation">{</span>
    <span class="token comment">// &lt;1&gt; 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>startupShutdownMonitor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      
      <span class="token comment">// &lt;2&gt; 刷新上下文环境的准备工作，记录下容器的启动时间、标记'已启动'状态、对上下文环境属性进行校验</span>
      <span class="token function">prepareRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// &lt;3&gt; 创建并初始化一个 BeanFactory 对象 `beanFactory`，会加载出对应的 BeanDefinition 元信息们</span>
      <span class="token class-name">ConfigurableListableBeanFactory</span> beanFactory <span class="token operator">=</span> <span class="token function">obtainFreshBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// &lt;4&gt; 为 `beanFactory` 进行一些准备工作，例如添加几个 BeanPostProcessor，手动注册几个特殊的 Bean</span>
      <span class="token function">prepareBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// &lt;5&gt; 对 `beanFactory` 在进行一些后期的加工，交由子类进行扩展</span>
        <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// &lt;6&gt; 执行 BeanFactoryPostProcessor 处理器，包含 BeanDefinitionRegistryPostProcessor 处理器</span>
        <span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// &lt;7&gt; 对 BeanPostProcessor 处理器进行初始化，并添加至 BeanFactory 中</span>
        <span class="token function">registerBeanPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// &lt;8&gt; 设置上下文的 MessageSource 对象</span>
        <span class="token function">initMessageSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// &lt;9&gt; 设置上下文的 ApplicationEventMulticaster 对象，上下文事件广播器</span>
        <span class="token function">initApplicationEventMulticaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// &lt;10&gt; 刷新上下文时再进行一些初始化工作，交由子类进行扩展</span>
        <span class="token function">onRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// &lt;11&gt; 将所有 ApplicationListener 监听器添加至 `applicationEventMulticaster` 事件广播器，如果已有事件则进行广播</span>
        <span class="token function">registerListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// &lt;12&gt; 设置 ConversionService 类型转换器，**初始化**所有还未初始化的 Bean（不是抽象、单例模式、不是懒加载方式）</span>
        <span class="token function">finishBeanFactoryInitialization</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// &lt;13&gt; 刷新上下文的最后一步工作，会发布 ContextRefreshedEvent 上下文完成刷新事件</span>
        <span class="token function">finishRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// &lt;14&gt; 如果上面过程出现 BeansException 异常</span>
      <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeansException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isWarnEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">&quot;Exception encountered during context initialization - &quot;</span> <span class="token operator">+</span>
              <span class="token string">&quot;cancelling refresh attempt: &quot;</span> <span class="token operator">+</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// &lt;14.1&gt; “销毁” 已注册的单例 Bean</span>
        <span class="token function">destroyBeans</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// &lt;14.2&gt; 设置上下文的 `active` 状态为 `false`</span>
        <span class="token function">cancelRefresh</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// &lt;14.3&gt; 抛出异常</span>
        <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// &lt;15&gt; `finally` 代码块</span>
      <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// Reset common introspection caches in Spring's core, since we</span>
        <span class="token comment">// might not ever need metadata for singleton beans anymore...</span>
        <span class="token comment">// 清除相关缓存，例如通过反射机制缓存的 Method 和 Field 对象，缓存的注解元数据，缓存的泛型类型对象，缓存的类加载器</span>
        <span class="token function">resetCommonCaches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><p><strong><code>finishBeanFactoryInitialization(beanFactory)</code></strong>** 方法初始化了所有的非懒加载的单例bean。**</p> <h2 id="beandefinition-解析"><a href="#beandefinition-解析" class="header-anchor">#</a> BeanDefinition 解析</h2> <p>BeanDefinition 介绍</p> <h3 id="面向注解的解析"><a href="#面向注解的解析" class="header-anchor">#</a> 面向注解的解析</h3> <p>核心类是 <code>org.springframework.context.annotation.ClassPathBeanDefinitionScanner</code>。</p> <ol><li><p>该类在创建时设置了基于<code>@Component</code> 注解的过滤器。</p></li> <li><p>调用<code>doScan(String... basePackages)</code> 方法，根据过滤器扫描出包路径（入参的就是包路径）下符合条件 .class文件，生成 <code>BeanDefinition</code>。</p></li> <li><p>将 <code>BeanDefinition</code>封装成 <code>BeanDefinitionHolder</code>对象（这里多了一个 <code>beanName</code>），并注册到<code>BeanDefinitionRegistry</code>中</p></li> <li><p>如果代理模式是 <strong>TARGET_CLASS</strong>，则再创建一个 <code>BeanDefinition</code>代理对象（重新设置了相关属性），原始 <code>BeanDefinition</code>已注册（该处与<strong>AOP</strong>相关）</p></li></ol> <h2 id="spring-扩展点解析"><a href="#spring-扩展点解析" class="header-anchor">#</a> Spring 扩展点解析</h2> <h2 id="广播机制"><a href="#广播机制" class="header-anchor">#</a> 广播机制</h2> <h1 id="bean-的创建和生命周期"><a href="#bean-的创建和生命周期" class="header-anchor">#</a> bean 的创建和生命周期</h1> <p>创建 Bean 的过程如下：</p> <ul><li><p>Class 对象加载阶段</p></li> <li><p>实例化前阶段（如果返回了一个对象则直接返回，不会进行下面的阶段）</p></li> <li><p>实例化阶段</p></li> <li><p>实例化后阶段</p></li> <li><p>提前暴露单例 Bean（循环依赖处理的关键）</p></li> <li><p>属性填充阶段</p></li> <li><p>Aware 接口回调阶段</p></li> <li><p>初始化前阶段</p></li> <li><p>初始化阶段</p></li> <li><p>初始化后阶段</p></li></ul> <p><img src="http://img.stormbuf.top/java0-1559531915.jpg" alt=""></p> <h2 id="dogetbean-方法"><a href="#dogetbean-方法" class="header-anchor">#</a> doGetBean 方法</h2> <p><code>doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType, @Nullable final Object[] args, boolean typeCheckOnly)</code></p> <p>该方法是获取与创建bean的核心方法。</p> <h2 id="createbean"><a href="#createbean" class="header-anchor">#</a> createBean</h2> <p><code>AbstractAutowireCapableBeanFactory#createBean(String, RootBeanDefinition, Object[])</code></p> <p>该方法是创建bean的核心方法。由<code>doGetBean</code>调用。</p> <p><code>createBean</code>通过调用<code>doCreateBean</code>方法创建bean。</p> <p>过程大致如下：</p> <ol><li>获取 <code>mbd</code> 对应的 Class 对象，确保当前 Bean 能够被创建出来，调用 <code>resolveBeanClass(...)</code> 方法</li> <li>对所有的 MethodOverride 进行<strong>验证</strong>和<strong>准备</strong>工作（确保存在对应的方法，并设置为不能重复加载）</li> <li><strong>实例化前阶段</strong>在实例化前进行相关处理，会先调用所有 InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation
注意，如果这里返回对象不是 <code>null</code> 的话，不会继续往下执行原本初始化操作，<strong>直接返回</strong>，也就是说这个方法返回的是最终实例对象
可以通过这种方式<strong>提前返回</strong>一个代理对象，例如 AOP 的实现，或者 RPC 远程调用的实现（因为本地类没有远程能力，可以通过这种方式进行拦截）</li> <li>创建 Bean 对象 <code>beanInstance</code>，如果上一步没有返回代理对象，就只能走常规的路线进行 Bean 的创建了，调用 <code>doCreateBean(...)</code> 方法</li> <li>将 <code>beanInstance</code> 返回
可以看到这个方法中并没有开始真正 Bean 的创建，在这个方法的第 <code>4</code> 步会调用 <code>doCreateBean(...)</code> 方法创建 Bean</li></ol> <h2 id="docreatebean"><a href="#docreatebean" class="header-anchor">#</a> doCreateBean</h2> <p>过程大致如下：</p> <ol><li>Bean 的<strong>实例化阶段</strong>，会将 Bean 的实例对象封装成 BeanWrapperImpl 包装对象</li> <li>如果是单例模式，则先尝试从 <code>factoryBeanInstanceCache</code> 缓存中获取实例对象，并从缓存中移除</li> <li>使用合适的实例化策略来创建 Bean 的实例：工厂方法、构造函数自动注入、简单初始化，主要是将 BeanDefinition 转换为 BeanWrapper 对象
调用 <code>createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</code> 方法</li> <li>获取包装的实例对象 <code>bean</code>4.  获取包装的实例对象的类型 <code>beanType</code>2.  对 <code>RootBeanDefinition</code>（合并后）进行<strong>加工处理</strong>1.  如果该 <code>RootBeanDefinition</code>没有处理过，则进行下面的处理</li> <li>调用所有的 <code>MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition</code>，这个过程非常重要，例如 Spring 内有下面两个处理器：</li></ol> <ul><li><p><code>AutowiredAnnotationBeanPostProcessor</code>，会先解析出 <code>@Autowired</code> 和 <code>@Value</code> 注解标注的属性的注入元信息，后续进行依赖注入</p></li> <li><p><code>CommonAnnotationBeanPostProcessor</code>，会先解析出 <code>@Resource</code> 注解标注的属性的注入元信息，后续进行依赖注入，它也会找到 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解标注的方法，并构建一个 <code>LifecycleMetadata</code>对象，用于后续生命周期中的初始化和销毁</p></li></ul> <ol start="3"><li>设置该 <code>RootBeanDefinition</code>被处理过，避免重复处理</li> <li><strong>提前暴露</strong>这个 <code>bean</code>，如果可以的话，目的是解决单例模式 Bean 的循环依赖注入</li> <li>判断是否可以提前暴露，满足三个条件：单例模式、允许循环依赖（默认为 true）、当前单例 bean 正在被创建，在前面已经标记过</li> <li>创建一个 <code>ObjectFactory</code>实现类，用于返回当前正在被创建的 <code>bean</code>，提前暴露，保存在 <code>singletonFactories</code> （<strong>三级 Map</strong>）缓存中</li></ol> <hr> <p>接下来开始初始化上面的 <code>bean</code> 实例对象，会先创建一个 <code>Object exposedObject</code> 等于 <code>bean</code> （引用）
4.  对 <code>bean</code> 进行<strong>属性填充</strong>，注入对应的属性值，调用 <code>populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</code> 方法
5.  <strong>初始化</strong>这个 <code>exposedObject</code>，调用其初始化方法，调用 <code>initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd)</code> 方法</p> <hr> <ol start="6"><li><strong>循环依赖注入的检查</strong>1.  获取当前正在创建的 <code>beanName</code> 被依赖注入的早期引用，调用 <code>DefaultSingletonBeanRegistry#getSingleton(String beanName, boolean allowEarlyReference)</code> 方法。注意，这里有一个入参是 <code>false</code>，不会调用上面第 <code>3</code> 步的 <code>ObjectFactory</code>实现类，也就是说当前 <code>bean</code> 如果出现循环依赖注入，这里才能获取到提前暴露的引用</li> <li>如果出现了循环依赖注入，则进行接下来的检查工作</li> <li>如果 <code>exposedObject</code> 没有在初始化阶段中被改变，也就是没有被增强，则使用提前暴露的那个引用</li> <li>否则，<code>exposedObject</code> 已经不是被别的 Bean 依赖注入的那个 Bean，如果依赖当前 <code>beanName</code> 的 Bean（通过 <code>depends-on</code> 配置）已经被创建，则抛出异常</li> <li>为当前 <code>bean</code> 注册 <code>DisposableBeanAdapter</code>（如果需要的话），用于 Bean 生命周期中的销毁阶段</li> <li>返回创建好的 <code>exposedObject</code> 对象
概括：</li></ol> <ul><li><p>首先获取对应的 Class 对象，创建一个实例对象</p></li> <li><p>对这个实例对象进行属性填充</p></li> <li><p>调用这个实例对象的初始化方法</p></li></ul> <hr> <h2 id="createbeaninstance"><a href="#createbeaninstance" class="header-anchor">#</a> createBeanInstance</h2> <p>在 <code>doCreateBean</code> 被调用，创建一个 Bean 的实例对象，并将 Bean 的实例对象封装成 <code>BeanWrapperImpl</code>包装对象返回。</p> <p>过程大致如下：</p> <ol><li><p>获取 <code>beanName</code> 对应的 Class 对象</p></li> <li><p>如果存在 Supplier 实例化回调接口，则使用给定的回调方法创建一个实例对象</p></li> <li><p>如果配置了 <code>factory-method</code> 工厂方法，则调用该方法来创建一个实例对象，通过 @Bean 标注的方法会通过这里进行创建</p></li></ol> <hr> <p>如果上面两种情况都不是，那么就进行接下来正常创建 Bean 实例的一个过程</p> <ol><li><p>判断这个 RootBeanDefinition 的构造方法是否已经被解析出来了，因为找到最匹配的构造方法比较繁琐，找到后会设置到 RootBeanDefinition 中，避免重复这个过程</p></li> <li><p>RootBeanDefinition 的 <code>resolvedConstructorOrFactoryMethod</code> 是否不为空，不为空表示构造方法已经解析出来了</p></li> <li><p>构造方法已经解析出来了，则判断它的 <code>constructorArgumentsResolved</code> 是否不为空，不为空表示有入参，需要先获取到对应的入参（构造器注入）</p></li> <li><p>如果最匹配的构造方法已解析出来</p></li> <li><p>如果这个构造方法有入参，则找到最匹配的构造方法，这里会拿到已经被解析出来的这个方法，并找到入参（构造器注入），然后调用该方法返回一个实例对象（反射机制）</p></li> <li><p>否则，没有入参，直接调用解析出来构造方法，返回一个实例对象（反射机制）</p></li> <li><p>如果最匹配的构造方法还没开始解析，那么需要找到一个最匹配的构造方法，然后创建一个实例对象</p></li> <li><p>先尝试通过 SmartInstantiationAwareBeanPostProcessor 处理器找到一些合适的构造方法，保存在 <code>ctors</code> 中</p></li> <li><p>是否满足下面其中一个条件：<code>ctors</code> 不为空、构造器注入模式、定义了构造方法的入参、当前方法指定了入参，</p></li></ol> <div class="language- extra-class"><pre><code>则找到最匹配的构造方法，如果 `ctors` 不为空，会从这里面找一个最匹配的，并找到入参（构造器注入），然后调用该方法返回一个实例对象（反射机制）
</code></pre></div><ol><li><p>如果第 <code>6</code> 步还不满足，那么尝试从 RootBeanDefinition 中获取优先的构造方法</p></li> <li><p>如果存在优先的构造方法，则从里面找到最匹配的一个，并找到入参（构造器注入），然后调用该方法返回一个实例对象（反射机制）</p></li> <li><p>如果上面多种情况都不满足，那只能使用兜底方法了，直接调用默认构造方法返回一个实例对象（反射机制）</p></li></ol> <hr> <p>整个的实例化过程非常的复杂，接下来进行概括：</p> <ul><li><p>先拿到对应 Class 对象</p></li> <li><p>如果设置了 Supplier 实例化回调接口，则通过该回调接口获取实例对象</p></li> <li><p>如果配置了通过 <code>factory-method</code> 工厂方法获取实例对象，则通过这个方法创建实例对象，@Bean 标注的方法也是通过这里创建实例对象，方法入参会依赖注入</p></li> <li><p>找到最匹配的一个构造方法，并找到对应的入参（构造器注入），通过调用该方法返回一个实例对象</p></li> <li><p>兜底方法，调用默认构造方法创建一个实例对象</p></li></ul> <p>BeanWrapperImpl 承担的角色：</p> <ol><li><p>Bean 实例的包装</p></li> <li><p><code>org.springframework.beans.PropertyAccessor</code>  属性编辑器</p></li> <li><p><code>org.springframework.beans.PropertyEditorRegistry</code>  属性编辑器注册表</p></li> <li><p>类型转换器</p></li></ol> <h2 id="populatebean"><a href="#populatebean" class="header-anchor">#</a> populateBean</h2> <p>用作<strong>属性填充</strong>。</p> <h2 id="三级缓存"><a href="#三级缓存" class="header-anchor">#</a> 三级缓存</h2> <p>作用：解决属性注入和Setter注入的循环依赖，无法解决构造器注入的循环依赖。</p> <p>说明：这里的循环依赖指的是<strong>单例模式</strong>下的 Bean <strong>字段注入</strong>时出现的循环依赖。<strong>构造器注入</strong>对于 Spring 无法自动解决（应该考虑代码设计是否有问题），可通过延迟初始化来处理。Spring 只解决<strong>单例模式</strong>下的循环依赖。</p> <p>在 Spring 底层 IoC 容器 BeanFactory 中处理循环依赖的方法主要借助于以下 <code>3</code> 个 Map 集合：</p> <ol><li><p><code>singletonObjects</code>（一级 Map），里面保存了所有已经初始化好的单例 Bean，也就是会保存 Spring IoC 容器中所有单例的 Spring Bean；</p></li> <li><p><code>earlySingletonObjects</code>（二级 Map），里面会保存从 <strong>三级 Map</strong> 获取到的正在初始化的 Bean</p></li> <li><p><code>singletonFactories</code>（三级 Map），里面保存了正在初始化的 Bean 对应的 ObjectFactory 实现类，调用其 getObject() 方法返回正在初始化的 Bean 对象（仅实例化还没完全初始化好），如果存在则将获取到的 Bean 对象并保存至 <strong>二级 Map</strong>，同时从当前 <strong>三级 Map</strong> 移除该 ObjectFactory 实现类。</p></li></ol> <p>当通过 getBean 依赖查找时会首先依次从上面三个 Map 获取，存在则返回，不存在则进行初始化，这三个 Map 是处理循环依赖的关键。</p> <p>例如两个 Bean 出现循环依赖，A 依赖 B，B 依赖 A；当我们去依赖查找 A，在实例化后初始化前会先生成一个 ObjectFactory 对象（可获取当前正在初始化 A）保存在上面的 <code>singletonFactories</code> 中，初始化的过程需注入 B；接下来去查找 B，初始 B 的时候又要去注入 A，又去查找 A ，由于可以通过 <code>singletonFactories</code> 直接拿到正在初始化的 A，那么就可以完成 B 的初始化，最后也完成 A 的初始化，这样就避免出现循环依赖。</p> <blockquote><p>B（也依赖 A） -&gt; C -&gt; A，当你获取 A 这个 Bean 时，后续 B 和 C 都要注入 A，没有上面的 <strong>二级 Map</strong>的话，<strong>三级 Map</strong> 保存的 ObjectFactory 实现类会被调用两次，会重复处理，可能出现问题，这样做在性能上也有所提升
<strong>问题二</strong>：为什么不直接调用这个 ObjectFactory#getObject() 方法放入 <strong>二级Map</strong> 中，而需要上面的 <strong>三级 Map</strong>？
对于不涉及到 AOP 的 Bean 确实可以不需要 <code>singletonFactories</code>（三级 Map），但是 Spring AOP 就是 Spring 体系中的一员，如果没有<code>singletonFactories</code>（三级 Map），意味着 Bean 在实例化后就要完成 AOP 代理，这样违背了 Spring 的设计原则。Spring 是通过 <code>AnnotationAwareAspectJAutoProxyCreator</code> 这个后置处理器在完全创建好 Bean 后来完成 AOP 代理，而不是在实例化后就立马进行 AOP 代理。如果出现了循环依赖，那没有办法，只有给 Bean 先创建代理对象，但是在没有出现循环依赖的情况下，设计之初就是让 Bean 在完全创建好后才完成 AOP 代理。</p></blockquote> <blockquote><p>提示：<code>AnnotationAwareAspectJAutoProxyCreator</code> 是一个 <code>SmartInstantiationAwareBeanPostProcessor</code> 后置处理器，在它的 getEarlyBeanReference(..) 方法中可以创建代理对象。所以说对于上面的<strong>问题二</strong>，如果出现了循环依赖，如果是一个 AOP 代理对象，那只能给 Bean 先创建代理对象，设计之初就是让 Bean 在完全创建好后才完成 AOP 代理。</p></blockquote> <blockquote><p>为什么 Spring 的设计是让 Bean 在完全创建好后才完成 AOP 代理？</p></blockquote> <p>因为创建的代理对象需要关联目标对象，在拦截处理的过程中需要根据目标对象执行被拦截的方法，所以这个目标对象最好是一个“成熟态”，而不是仅实例化还未初始化的一个对象。</p> <h1 id="aop"><a href="#aop" class="header-anchor">#</a> aop</h1> <p>Bean 的加载过程，整个过程中会调用相应的 BeanPostProcessor 对正在创建 Bean 进行处理，例如：</p> <ol><li><p>在 Bean 的实例化前，会调用 <code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation(..)</code> 方法进行处理</p></li> <li><p>在 Bean 出现循环依赖的情况下，会调用 <code>SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference(..)</code> 方法对提前暴露的 Bean 进行处理</p></li> <li><p>在 Bean 初始化后，会调用 <code>BeanPostProcessor#postProcessAfterInitialization(..)</code> 方法对初始化好的 Bean 进行处理</p></li></ol> <p>Spring AOP 则是通过上面三个切入点进行创建代理对象，实现<strong>自动代理</strong>。</p> <ul><li><p>在 Spring AOP 中主要是通过第 <code>3</code> 种 BeanPostProcessor 创建代理对象，在 Bean 初始化后，也就是一个“成熟态”，然后再尝试是否创建一个代理对象；</p></li> <li><p>第 <code>2</code> 种方式是为了解决 Bean 循环依赖的问题，虽然 Bean 仅实例化还未初始化，但是出现了循环依赖，不得不在此时创建一个代理对象；</p></li> <li><p>第 <code>1</code> 种方式是在 Bean 还没有实例化的时候就提前创建一个代理对象（创建了则不会继续后续的 Bean 的创建过程），例如 RPC 远程调用的实现，因为本地类没有远程能力，可以通过这种方式进行拦截。</p></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">2021-08-25 18:24</span></div></footer> <!----> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.586101e3.js" defer></script><script src="/assets/js/2.f36e1316.js" defer></script><script src="/assets/js/16.6195d00e.js" defer></script><script src="/assets/js/4.efbf2f21.js" defer></script>
  </body>
</html>
